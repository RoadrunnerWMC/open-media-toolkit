/*****************************************************************        O P E N      M E D I A     T O O L K I T              V2.5             Copyright Yves Schmid 1996-2003         See www.garagecube.com for more informations about this library.                Author(s): Yves Schmid         OMT is provided under LGPL:           This library is free software; you can redistribute it and/or          modify it under the terms of the GNU Lesser General Public          License as published by the Free Software Foundation; either          version 2.1 of the License, or (at your option) any later version.          This library is distributed in the hope that it will be useful,          but WITHOUT ANY WARRANTY; without even the implied warranty of          MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU          Lesser General Public License for more details.          You should have received a copy of the GNU Lesser General Public          License along with this library; if not, write to the Free Software          Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA          The full text of the license can be found in lgpl.txt          ******************************************************************/#include "CDocumentApp.h"#include "AppConstants.h"#include "LOMTWindow.h"#include "ExtraDefs.h"#include "OMediaCanvas.h"#include "OMediaSound.h"#include "OMedia3DMaterial.h"#include "OMedia3DShape.h"#include "OMedia3DShapeConverter.h"#include "OMedia3DMorphAnim.h"#include "OMedia3DShapeElement.h"#include "OMediaElementContainer.h"#include <LGrowZone.h>#include <PP_Messages.h>#include <PP_Resources.h>#include <UDrawingState.h>#include <UMemoryMgr.h>#include <URegistrar.h>#include <UEnvironment.h>#include <UAttachments.h>#include <LDocument.h>#include <LUndoer.h>#include <LWindow.h>#include <LPrintout.h>#include <LPlaceHolder.h>#include <UDesktop.h>#include <UStandardDialogs.h>#include <UControlRegistry.h>#include <LGAColorSwatchControl.h>#include <LGroupBox.h>#include <LTabGroupView.h>#include <LTextColumn.h>#include <LRadioGroupView.h>#include "CDBDocument.h"#include "LDBHierTable.h"#include "LAquaBackLines.h"#include "LMsgEditField.h"#include "LCanvasView.h"#include "LOMTWorldView.h"#include <Appearance.h>vector<CCreateObjectDef>	 CDocumentApp::createObjectList;// ===========================================================================//	¥ main// ===========================================================================int main(){									// Set Debugging options	SetDebugThrow_(debugAction_Alert);	SetDebugSignal_(debugAction_Alert);		// Initialize Memory Manager. Parameter is the number of		// master pointer blocks to allocate	InitializeHeap(3);			// Initialize standard Toolbox managers	UQDGlobals::InitializeToolbox();			// Install a GrowZone to catch low-memory situations		new LGrowZone(20000);		// Create the application object and run	CDocumentApp	theApp;	theApp.Run();		return 0;}// ---------------------------------------------------------------------------//	¥ CDocumentApp									[public]// ---------------------------------------------------------------------------//	Application object constructorCDocumentApp::CDocumentApp(){	OMediaDataBase::set_cache_size(30000*1000);		// Register ourselves with the Appearance Manager	if (UEnvironment::HasFeature(env_HasAppearance)) {		::RegisterAppearanceClient();	}	RegisterClasses();	registerObjectTypes();			// Preload facilities for the Standard Dialogs	PP_StandardDialogs::Load();			// Require at least Navigation Services 1.1. See comments		// above SetTryNavServices in UConditionalDialogs.cp for why		// you might wish to do this.#if PP_StdDialogs_Option == PP_StdDialogs_Conditional	UConditionalDialogs::SetTryNavServices(0x01108000);#endif}void CDocumentApp::registerObjectTypes(void){	omd_REGISTERCLASS(OMediaCanvas);	omd_REGISTERCLASS(OMediaSound);	omd_REGISTERCLASS(OMedia3DMaterial);	omd_REGISTERCLASS(OMedia3DShape);	omd_REGISTERCLASS(OMediaElement);	omd_REGISTERCLASS(OMedia3DMorphAnimDef);	omd_REGISTERCLASS(OMedia3DMorphAnim);	omd_REGISTERCLASS(OMedia3DShapeElement);	omd_REGISTERCLASS(OMediaElementContainer);	registerCreateObject("Canvas",OMediaCanvas::db_type);	CExtraObjectSupport::registerDBClasses(this);		OMedia3DShapeConverter::set_texture_conv_mode(omctxtconv_ImportIfNotFound);	// Set default converter options}// ---------------------------------------------------------------------------//	¥ ~CDocumentApp									[public, virtual]// ---------------------------------------------------------------------------//	Application object destructorCDocumentApp::~CDocumentApp(){		// Clean up after Standard Dialogs	PP_StandardDialogs::Unload();}// ---------------------------------------------------------------------------//	¥ StartUp										[protected, virtual]// ---------------------------------------------------------------------------//	Perform an action in response to the Open Application AppleEvent.//	Here, issue the New command to open a window.voidCDocumentApp::StartUp(){	ObeyCommand(cmd_New, nil);}// ---------------------------------------------------------------------------//	¥ DoReopenApp									[protected, virtual]// ---------------------------------------------------------------------------//	Support the Finder's "re-open application" ('rapp') Apple Event. From//	Apple TechNote 1102 (on Mac OS 8):////		The Finder now sends a 're-open application' Apple event ('rapp') to//		applications when the application is already running and it is opened//		from one of the Finder's windows (either by a double click or by//		selecting the application and choosing the Open command). Applications//		receiving a 'rapp' event (when they do not have any windows open) should//		open a new untitled document just as they would when processing an 'oapp'//		event.voidCDocumentApp::DoReopenApp(){		// Given the suggested course of action by TN1102, the appropriate		// action to take would be the equivalent of calling StartUp(). You		// could call that here if you wish, but PowerPlant (nor this stationery)		// will do that by default as StartUp() may contain code that one would		// only wish to execute in response to an 'oapp' event, e.g. displaying		// a splash screen. Additionally, 'rapp' should only open the new		// untitled document if there are no other windows open.		//		// Given these circumstances, we'll create a new untitled document		// (cmd_New) if no regular or modal windows are open (the TN didn't		// address layers, but we'll assume this is what they mean).		if ((UDesktop::FetchTopRegular() == nil)		&& (UDesktop::FetchTopModal() == nil)) {		ObeyCommand(cmd_New, nil);	}}// ---------------------------------------------------------------------------//	¥ ObeyCommand									[public, virtual]// ---------------------------------------------------------------------------//	Respond to Commands. Returns true if the Command was handled, false if not.BooleanCDocumentApp::ObeyCommand(	CommandT	inCommand,	void*		ioParam){	Boolean		cmdHandled = true;	// Assume we'll handle the command	switch (inCommand) {		default: {			cmdHandled = LDocApplication::ObeyCommand(inCommand, ioParam);			break;		}	}		return cmdHandled;}// ---------------------------------------------------------------------------//	¥ FindCommandStatus								[public, virtual]// ---------------------------------------------------------------------------//	Determine the status of a Command for the purposes of menu updating.voidCDocumentApp::FindCommandStatus(	CommandT	inCommand,	Boolean&	outEnabled,	Boolean&	outUsesMark,	UInt16&		outMark,	Str255		outName){	switch (inCommand) {		default: {			LDocApplication::FindCommandStatus(inCommand, outEnabled,											outUsesMark, outMark, outName);			break;		}	}}// ---------------------------------------------------------------------------//	¥ OpenDocument									[protected, virtual]// ---------------------------------------------------------------------------// This method is called when a file is chosen from the Open File dialog.voidCDocumentApp::OpenDocument(	FSSpec*		inMacFSSpec){	LDocument*	theDoc = LDocument::FindByFileSpec(*inMacFSSpec);			// If the document is already open make it the current document,		// else create a new document.	if (theDoc != nil) {		theDoc->MakeCurrent();	} else {									theDoc = new CDBDocument(this, inMacFSSpec);	}}// ---------------------------------------------------------------------------//	¥ MakeNewDocument								[protected, virtual]// ---------------------------------------------------------------------------// This method creates a new document and installs it into the application's// Apple Event Object Model hierarchy.LModelObject*CDocumentApp::MakeNewDocument(){		// Make a new empty document.	return new CDBDocument(this, nil);}// ---------------------------------------------------------------------------//	¥ ChooseDocument								[protected, virtual]// ---------------------------------------------------------------------------// This method uses the PowerPlant Standard Dialogs to let the user choose a// document to open.pascal static Boolean NavOMTDBFileFilter(AEDesc *theItem, void *info, void *callBackUD, NavFilterModes filterMode){	FSSpec	*spec;	if (theItem->descriptorType!=typeFSS) return true;		NavFileOrFolderInfo	*finfo = (NavFileOrFolderInfo*)info;	if (finfo->isFolder) return true;			if (finfo->fileAndFolder.fileInfo.finderInfo.fdType==ResType_OMTDOCUMENT) return true;		HLock((Handle)theItem->dataHandle);	spec = (FSSpec*)(*theItem->dataHandle);		int nlen = 	spec->name[0];	unsigned char *p = spec->name+1;		Boolean res = false;		if (nlen>4)	{		if ((p[nlen-1]=='t' || p[nlen-1]=='T') &&			(p[nlen-2]=='m' || p[nlen-2]=='M') &&			(p[nlen-3]=='o' || p[nlen-3]=='O') &&			(p[nlen-4]=='.')) res = true;	}	HUnlock((Handle)theItem->dataHandle);		return res;}voidCDocumentApp::ChooseDocument(){	PP_StandardDialogs::LFileChooser	chooser;			// Open any/all TEXT files		NavDialogOptions*	options = chooser.GetDialogOptions();		chooser.SetObjectFilterProc(NavOMTDBFileFilter);		if (options != nil) 	{		options->dialogOptionFlags =	kNavDefaultNavDlogOptions										+ kNavSelectAllReadableItem;	}	if (chooser.AskOpenFile(LFileTypeList(fileTypes_All))) 	{		AEDescList		docList;		chooser.GetFileDescList(docList);		SendAEOpenDocList(docList);	}}// ---------------------------------------------------------------------------//	¥ PrintDocument									[protected, virtual]// ---------------------------------------------------------------------------// This method is called in response to a Print requestvoidCDocumentApp::PrintDocument(	FSSpec*		inMacFSSpec){		// Create a new document using the file spec.	CDBDocument*	theDocument = new CDBDocument(this, inMacFSSpec);		// Tell the document to print.	theDocument->DoPrint();}// ---------------------------------------------------------------------------//	¥ RegisterClasses								[protected]// ---------------------------------------------------------------------------//	To reduce clutter within the Application object's constructor, class//	registrations appear here in this seperate function for ease of use.voidCDocumentApp::RegisterClasses(){		// Register core PowerPlant classes.	RegisterClass_(LWindow);	RegisterClass_(LPrintout);	RegisterClass_(LPlaceHolder);	RegisterClass_(LKeyScrollAttachment);	RegisterClass_(LColorEraseAttachment);	RegisterClass_(LUndoer);	RegisterClass_(LCaption);	RegisterClass_(LStdPopupMenu);	RegisterClass_(LStdRadioButton);	RegisterClass_(LEditField);	RegisterClass_(LStdButton);	RegisterClass_(LStdCheckBox);	RegisterClass_(LGroupBox);		RegisterClass_(LPane);	RegisterClass_(LTabGroupView);	RegisterClass_(LRadioGroupView);	RegisterClass_(LGAColorSwatchControl);	RegisterClass_(LTextColumn);		// Register the Appearance Manager/GA classes. You may want		// to remove this use of UControlRegistry and instead perform		// a "manual" registration of the classes. This cuts down on		// extra code being linked in and streamlines your app and		// project. However, use UControlRegistry as a reference/index		// for your work, and ensure to check UControlRegistry against		// your registrations each PowerPlant release in case		// any mappings might have changed.			UControlRegistry::RegisterClasses();		// Register custom classes	//RegisterClass_(CTextView);		RegisterClass_(LTextHierTable);	RegisterClass_(LHierarchyTable);	RegisterClass_(LDBHierTable);	RegisterClass_(LAquaBackLines);	RegisterClass_(LMsgEditField);	RegisterClass_(LView);	RegisterClass_(LCanvasView);	RegisterClass_(LOMTWindow);	RegisterClass_(LOMTWorldView);	RegisterClass_(LOMTViewPort);	}void CDocumentApp::ShowAboutBox(){	StDialogHandler	theHandler(1104, this);	LWindow*		theDialog = theHandler.GetDialog();	LStr255			pstr;	theDialog->SetThemeData(kThemeBackgroundPlacard, kThemeBackgroundPlacard,							 kThemeTextColorDialogActive, kThemeTextColorDialogInactive);	theDialog->Show();	MessageT	hitMessage;	for(;;)	{		hitMessage = theHandler.DoDialog();		if (hitMessage!=msg_Nothing) break;	}	}