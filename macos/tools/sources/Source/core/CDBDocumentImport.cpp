/*****************************************************************        O P E N      M E D I A     T O O L K I T              V2.5             Copyright Yves Schmid 1996-2003         See www.garagecube.com for more informations about this library.                Author(s): Yves Schmid         OMT is provided under LGPL:           This library is free software; you can redistribute it and/or          modify it under the terms of the GNU Lesser General Public          License as published by the Free Software Foundation; either          version 2.1 of the License, or (at your option) any later version.          This library is distributed in the hope that it will be useful,          but WITHOUT ANY WARRANTY; without even the implied warranty of          MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU          Lesser General Public License for more details.          You should have received a copy of the GNU Lesser General Public          License along with this library; if not, write to the Free Software          Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA          The full text of the license can be found in lgpl.txt          ******************************************************************/#include "CDBDocument.h"#include <LFile.h>#include <LPlaceHolder.h>#include <LPrintout.h>#include <LString.h>#include <LWindow.h>#include <PP_Messages.h>#include <UMemoryMgr.h>#include <UResourceMgr.h>#include <UWindows.h>#include "AppConstants.h"#include "LDBHierTable.h"#include "CCanvasEditor.h"#include "CSoundEditor.h"#include "CMaterialEditor.h"#include "C3DShapeEditor.h"#include "OMedia3DShape.h"#include "OMediaCanvas.h"#include "OMediaSound.h"#include "OMedia3DMaterial.h"#include "OMediaMacRtgFilePath.h"#include "OMediaFilePath.h"#include "OMediaFileStream.h"#include "OMedia3DShapeConverter.h"#include "OMediaElement.h"#include "LMsgEditField.h"#include "LTextColumn.h"#include "OMediaString.h"#include <string>//-------------------------------------------// Global Import Optionsstatic omt_FSChunkID	baseID;static string			prefixName;static string			customType;static bool				removeFileExtension;//-------------------------------------------static unsigned long getnearestpow(unsigned long n);static unsigned long getnearestpow(unsigned long n){	unsigned long bit;	for(bit= 32;;)	{		bit--;				if (n&(1<<bit)) return (1<<bit);		if (bit==0) break;	}		return 0;}//-------------------------------------------static string checkFileExtension(string str);static string checkFileExtension(string str){	if (removeFileExtension)	{		if (str.size()>4 && str[str.size()-4]=='.') str.resize(str.size()-4);		}		return str;}//-------------------------------------------static void updateImportState(LWindow *dialog);static void updateImportState(LWindow *theDialog){	LRadioGroupView	*rg;	bool			canImport = false;	bool			customDB = false;	Str255			pstr;	LEditField		*eCustomDBType;	eCustomDBType = dynamic_cast<LEditField*>(theDialog->FindPaneByID(10));	rg = dynamic_cast<LRadioGroupView*>(theDialog->FindPaneByID(50));	switch(rg->GetCurrentRadioID())	{		case 1:		canImport = true;		break;		case 2:		canImport = true;		break;		case 3:		canImport = true;		break;		case 4:		customDB = true;		eCustomDBType->GetDescriptor(pstr);		canImport = (pstr[0]==4);		break;		}		LStdControl	*c;	c = dynamic_cast<LStdControl*>(theDialog->FindPaneByID(20));	if (canImport) c->Enable(); else c->Disable();	if (customDB) eCustomDBType->Enable(); else eCustomDBType->Disable();	}void CDBDocument::import(){	StDialogHandler	theHandler(1109, mWindow);	LWindow*		theDialog = theHandler.GetDialog();	LRadioGroupView	*rg;	rg = dynamic_cast<LRadioGroupView*>(theDialog->FindPaneByID(50));	rg->SetCurrentRadioID(1);		theDialog->SetThemeData(kThemeBackgroundPlacard, kThemeBackgroundPlacard,							 kThemeTextColorDialogActive, kThemeTextColorDialogInactive);	updateImportState(theDialog);	theDialog->Show();	MessageT	hitMessage;	for(;;)	{		hitMessage = theHandler.DoDialog();		if (hitMessage==msg_OK ||			hitMessage==msg_Cancel) break;				if (hitMessage==1124)			importCanvasOptions(theDialog);		else if (hitMessage==1125)			import3DShapeOptions(theDialog);					updateImportState(theDialog);	}		if (hitMessage==msg_OK) 	{		LStdControl	*c;		LEditField	*ef;		Str255		pstr;			ef = dynamic_cast<LEditField*>(theDialog->FindPaneByID(12));				baseID = ef->GetValue();				ef = dynamic_cast<LEditField*>(theDialog->FindPaneByID(11));		ef->GetDescriptor(pstr);				prefixName = Str255toString(pstr);		ef = dynamic_cast<LEditField*>(theDialog->FindPaneByID(10));		ef->GetDescriptor(pstr);		customType = Str255toString(pstr);			c = dynamic_cast<LStdControl*>(theDialog->FindPaneByID(13));		removeFileExtension = (c->GetValue())!=0;			doImportFiles(rg->GetCurrentRadioID());				mHierarchyView->rebuildTable();		updateInfoCaptions();		SetModified(true);	}		LCommander::SwitchTarget(mHierarchyView);}//-------------------------------------------------------------------------------// Import soundpascal static Boolean NavSoundFileFilter(AEDesc *theItem, void *info, void *callBackUD, NavFilterModes filterMode){	FSSpec	*spec;	if (theItem->descriptorType!=typeFSS) return true;		NavFileOrFolderInfo	*finfo = (NavFileOrFolderInfo*)info;	if (finfo->isFolder) return true;	if (finfo->fileAndFolder.fileInfo.finderInfo.fdType=='WAVf') return true;		HLock((Handle)theItem->dataHandle);	spec = (FSSpec*)(*theItem->dataHandle);		int nlen = 	spec->name[0];	unsigned char *p = spec->name+1;		Boolean res = false;		if (nlen>4)	{		if ((p[nlen-1]=='v' || p[nlen-1]=='V') &&			(p[nlen-2]=='a' || p[nlen-2]=='A') &&			(p[nlen-3]=='w' || p[nlen-3]=='W') &&			(p[nlen-4]=='.')) res = true;	}	HUnlock((Handle)theItem->dataHandle);		return res;}//--------------------------------------------------------void CDBDocument::importSound(FSSpec documentFSSpec){	OMediaFilePath	path;	OMediaMacRtgFilePath *rtgPath = (OMediaMacRtgFilePath*)path.getretarget();	string			name;		rtgPath->fsspec = documentFSSpec;		OMediaFileStream	file;		try	{		file.setpath(&path);		file.open(omcfp_Read,false,false);		OMediaSound	*snd;				snd = omd_GETOBJECT(dbase,OMediaSound,								dbase->get_unique_chunkid(OMediaSound::db_type,baseID));				file>>snd;		name = prefixName;		name += Str255toString(documentFSSpec.name);				snd->set_chunk_name(checkFileExtension(name));		snd->set_modified(true);		snd->db_update();		snd->get_database()->close_chunk();		// To force size to be updated		snd->db_unlock();						file.close();		}	catch(...)	{		// +++ Should display an error message	}}//-------------------------------------------------------------------------------// Import Customvoid CDBDocument::importCustom(FSSpec documentFSSpec){	OMediaFilePath	path;	OMediaMacRtgFilePath *rtgPath = (OMediaMacRtgFilePath*)path.getretarget();	string			name;		rtgPath->fsspec = documentFSSpec;		OMediaFileStream	file;		try	{		file.setpath(&path);		file.open(omcfp_Read,false,false);		omt_ChunkType 	dbtype;		omt_FSChunkID	dbid;						dbtype = (customType[0]<<24)|(customType[1]<<16)|(customType[2]<<8)|(customType[3]<<0);		dbid = dbase->get_unique_chunkid(dbtype,baseID);		name = prefixName;		name += Str255toString(documentFSSpec.name);				dbase->import_chunk(&file, file.getsize(),dbtype,dbid);		dbase->set_chunk_name(dbtype,dbid,checkFileExtension(name));		dbase->close_chunk();		// To force size to be updated						file.close();		}	catch(...)	{		// +++ Should display an error message	}}//-------------------------------------------------------------------------------// Import Canvas optionsstatic long					CanvImport_subdiv_w=-1,CanvImport_subdiv_h=-1;static omt_PixelFormat		CanvImport_internal_pixel_format=ompixfc_Best;static omt_CanvasFiltering	CanvImport_min_filtering = omtfc_Nearest,							CanvImport_mag_filtering = omtfc_Nearest;//-------------------------------------------pascal static Boolean NavCanvasFileFilter(AEDesc *theItem, void *info, void *callBackUD, NavFilterModes filterMode){	FSSpec	*spec;	if (theItem->descriptorType!=typeFSS) return true;		NavFileOrFolderInfo	*finfo = (NavFileOrFolderInfo*)info;	if (finfo->isFolder) return true;	if (finfo->fileAndFolder.fileInfo.finderInfo.fdType=='GIFf' ||		finfo->fileAndFolder.fileInfo.finderInfo.fdType=='PNGf') return true;		HLock((Handle)theItem->dataHandle);	spec = (FSSpec*)(*theItem->dataHandle);		int nlen = 	spec->name[0];	unsigned char *p = spec->name+1;		Boolean res = false;		if (nlen>4)	{		if ((p[nlen-1]=='g' || p[nlen-1]=='G') &&			(p[nlen-2]=='n' || p[nlen-2]=='N') &&			(p[nlen-3]=='p' || p[nlen-3]=='P') &&			(p[nlen-4]=='.')) res = true;		if ((p[nlen-1]=='F' || p[nlen-1]=='F') &&			(p[nlen-2]=='I' || p[nlen-2]=='I') &&			(p[nlen-3]=='G' || p[nlen-3]=='G') &&			(p[nlen-4]=='.')) res = true;	}	HUnlock((Handle)theItem->dataHandle);		return res;}//--------------------------------------------------------void CDBDocument::importCanvas(FSSpec documentFSSpec){	OMediaFilePath	path;	OMediaMacRtgFilePath *rtgPath = (OMediaMacRtgFilePath*)path.getretarget();	string			name;		rtgPath->fsspec = documentFSSpec;		OMediaFileStream	file;		try	{		file.setpath(&path);		file.open(omcfp_Read,false,false);		OMediaCanvas	*canvas;				canvas = omd_GETOBJECT(dbase,OMediaCanvas,								dbase->get_unique_chunkid(OMediaCanvas::db_type,baseID));				file>>canvas;		name = prefixName;		name += Str255toString(documentFSSpec.name);				canvas->set_chunk_name(checkFileExtension(name));		canvas->set_2Dsubdivision(CanvImport_subdiv_w,CanvImport_subdiv_h);		canvas->set_filtering(CanvImport_mag_filtering,CanvImport_min_filtering);		canvas->set_internal_pixel_format(CanvImport_internal_pixel_format);		canvas->set_modified(true);		canvas->db_update();		canvas->get_database()->close_chunk();		// To force size to be updated		canvas->db_unlock();						file.close();		}	catch(...)	{		// +++ Should display an error message	}}//--------------------------------------------------------void CDBDocument::importCanvasOptions(LWindow *superWin){	StDialogHandler	theHandler(1110, superWin);	LWindow*		theDialog = theHandler.GetDialog();	MessageT	hitMessage;	theDialog->SetThemeData(kThemeBackgroundPlacard, kThemeBackgroundPlacard,							 kThemeTextColorDialogActive, kThemeTextColorDialogInactive);	LMsgEditField	*e;	LStr255			lstr;	LStdPopupMenu	*p;	e  = dynamic_cast<LMsgEditField*>(theDialog->FindPaneByID(35)); Assert_(e != nil);	lstr = CanvImport_subdiv_w;	e->SetDescriptor(lstr);	e =  dynamic_cast<LMsgEditField*>(theDialog->FindPaneByID(36)); Assert_(e != nil);	lstr = CanvImport_subdiv_h;	e->SetDescriptor(lstr);	p = dynamic_cast<LStdPopupMenu*>(theDialog->FindPaneByID(32)); Assert_(p != nil);	switch(CanvImport_min_filtering)	{		case omtfc_Nearest: p->SetValue(1); break;		case omtfc_Linear: p->SetValue(2); break;		case omtfc_Nearest_Mipmap_Nearest: p->SetValue(3); break;		case omtfc_Nearest_Mipmap_Linear: p->SetValue(4); break;		case omtfc_Linear_Mipmap_Nearest: p->SetValue(5); break;		case omtfc_Linear_Mipmap_Linear: p->SetValue(6); break;		}	p = dynamic_cast<LStdPopupMenu*>(theDialog->FindPaneByID(33)); Assert_(p != nil);	switch(CanvImport_mag_filtering)	{		case omtfc_Nearest: p->SetValue(1); break;		case omtfc_Linear: p->SetValue(2); break;	}		p = dynamic_cast<LStdPopupMenu*>(theDialog->FindPaneByID(34)); Assert_(p != nil);	switch(CanvImport_internal_pixel_format)	{		case ompixfc_Best: 				p->SetValue(1); break;		case ompixfc_ResBest: 			p->SetValue(2); break;		case ompixfc_ResBestAlpha: 		p->SetValue(3); break;		case ompixfc_ResBestAlpha1bit: 	p->SetValue(4); break;		default:						p->SetValue(5); break;	}	theDialog->Show();	for(;;)	{		hitMessage = theHandler.DoDialog();		if (hitMessage==msg_OK ||			hitMessage==msg_Cancel) break;	}		if (hitMessage==msg_OK)	{			// Subdiv width			e  = dynamic_cast<LMsgEditField*>(theDialog->FindPaneByID(35)); Assert_(e != nil);		CanvImport_subdiv_w = e->GetValue();				CanvImport_subdiv_w = getnearestpow(CanvImport_subdiv_w);		if (CanvImport_subdiv_w<=0) CanvImport_subdiv_w = -1;				// Subdiv height			e  = dynamic_cast<LMsgEditField*>(theDialog->FindPaneByID(36)); Assert_(e != nil);		CanvImport_subdiv_h = e->GetValue();				CanvImport_subdiv_h = getnearestpow(CanvImport_subdiv_h);		if (CanvImport_subdiv_h<=0) CanvImport_subdiv_h = -1;				// Min. filtering				p = dynamic_cast<LStdPopupMenu*>(theDialog->FindPaneByID(32)); Assert_(p != nil);		switch(p->GetValue())		{			case 1:			CanvImport_min_filtering = omtfc_Nearest;			break;						case 2:			CanvImport_min_filtering = omtfc_Linear;			break;			case 3:			CanvImport_min_filtering = omtfc_Nearest_Mipmap_Nearest;			break;			case 4:			CanvImport_min_filtering = omtfc_Nearest_Mipmap_Linear;			break;						case 5:			CanvImport_min_filtering = omtfc_Linear_Mipmap_Nearest;			break;						case 6:			CanvImport_min_filtering = omtfc_Linear_Mipmap_Linear;			break;		}				// Max. filtering		p = dynamic_cast<LStdPopupMenu*>(theDialog->FindPaneByID(33)); Assert_(p != nil);		switch(p->GetValue())		{			case 1:			CanvImport_mag_filtering = omtfc_Nearest;			break;						case 2:			CanvImport_mag_filtering = omtfc_Linear;			break;		}						// Pixel format				p = dynamic_cast<LStdPopupMenu*>(theDialog->FindPaneByID(34)); Assert_(p != nil);		switch(p->GetValue())		{			case 1:			CanvImport_internal_pixel_format = ompixfc_Best;			break;			case 2:			CanvImport_internal_pixel_format = ompixfc_ResBest;			break;			case 3:			CanvImport_internal_pixel_format = ompixfc_ResBestAlpha;			break;			case 4:			CanvImport_internal_pixel_format = ompixfc_ResBestAlpha1bit;			break;			case 5:			CanvImport_internal_pixel_format = ompixfc_Best;	// Other... set Best...			break;		}				}}//-----------------------------------------------------------------------------void CDBDocument::import3DShapeOptions(LWindow *superWin){	StDialogHandler	theHandler(1111, superWin);	LWindow*		theDialog = theHandler.GetDialog();	MessageT		hitMessage;	LStdControl		*c;	LEditField		*e;	LStr255			lstr;	string			str;	LStdPopupMenu	*p;	theDialog->SetThemeData(kThemeBackgroundPlacard, kThemeBackgroundPlacard,							 kThemeTextColorDialogActive, kThemeTextColorDialogInactive);	p = dynamic_cast<LStdPopupMenu*>(theDialog->FindPaneByID(31)); Assert_(p != nil);	switch(OMedia3DShapeConverter::get_texture_conv_mode())	{		case omctxtconv_Ignore: p->SetValue(1); break;		case omctxtconv_ImportIfNotFound: p->SetValue(2); break;		case omctxtconv_Create: p->SetValue(3); break;		case omctxtconv_Replace: p->SetValue(4); break;	}	p = dynamic_cast<LStdPopupMenu*>(theDialog->FindPaneByID(32)); Assert_(p != nil);	switch(OMedia3DShapeConverter::get_material_convert_mode())	{		case omc3dmconv_IgnoreMaterial: p->SetValue(1); break;		case omc3dmconv_CreateNewMaterialIfNotFound: p->SetValue(2); break;		case omc3dmconv_ExistingMaterialOnly: p->SetValue(3); break;		case omc3dmconv_AlwaysCreateNewMaterial: p->SetValue(4); break;		case omc3dmconv_ReplaceMaterial: p->SetValue(5); break;	}	p = dynamic_cast<LStdPopupMenu*>(theDialog->FindPaneByID(33)); Assert_(p != nil);	switch(OMedia3DShapeConverter::get_object_convert_mode())	{		case omc3doconv_MergeObjects: p->SetValue(1); break;		case omc3doconv_OneShapePerObject: p->SetValue(2); break;		case omc3doconv_OneShapePerGroup: p->SetValue(3); break;	}	p = dynamic_cast<LStdPopupMenu*>(theDialog->FindPaneByID(34)); Assert_(p != nil);	switch(OMedia3DShapeConverter::get_anim_conv_mode_mode())	{		case omc3danconv_Ignore: p->SetValue(1); break;		case omc3danconv_ReplaceMorphAnimDef: p->SetValue(2); break;		case omc3danconv_AlwaysCreateNewMorphAnimDef: p->SetValue(3); break;		case omc3danconv_AddSequence: p->SetValue(4); break;	}		c = dynamic_cast<LStdControl*>(theDialog->FindPaneByID(10)); Assert_(c != nil);	c->SetValue((OMedia3DShapeConverter::get_convert_flags()&om3dcf_MergeNormals)!=0);	c = dynamic_cast<LStdControl*>(theDialog->FindPaneByID(11)); Assert_(c != nil);	c->SetValue((OMedia3DShapeConverter::get_convert_flags()&om3dcf_MergeVerticesNormals)!=0);	c = dynamic_cast<LStdControl*>(theDialog->FindPaneByID(12)); Assert_(c != nil);	c->SetValue((OMedia3DShapeConverter::get_convert_flags()&om3dcf_MergeIdenticalMaterials)!=0);	c = dynamic_cast<LStdControl*>(theDialog->FindPaneByID(13)); Assert_(c != nil);	c->SetValue((OMedia3DShapeConverter::get_convert_flags()&om3dcf_OneMaterialPerTexture)!=0);		e  = dynamic_cast<LEditField*>(theDialog->FindPaneByID(14)); Assert_(e != nil);	OMedia3DShapeConverter::get_new_material_prefix(str);		lstr = str.c_str();	e->SetDescriptor(lstr);	e  = dynamic_cast<LEditField*>(theDialog->FindPaneByID(15)); Assert_(e != nil);	OMedia3DShapeConverter::get_new_texture_prefix(str);		lstr = str.c_str();	e->SetDescriptor(lstr);	c = dynamic_cast<LStdControl*>(theDialog->FindPaneByID(50)); Assert_(c != nil);	c->SetValue(OMedia3DShapeConverter::get_world_conv_mode()!=omcworldconv_None);	theDialog->Show();	for(;;)	{		hitMessage = theHandler.DoDialog();		if (hitMessage==msg_OK ||			hitMessage==msg_Cancel) break;	}		if (hitMessage==msg_OK)	{		p = dynamic_cast<LStdPopupMenu*>(theDialog->FindPaneByID(31)); Assert_(p != nil);		switch(p->GetValue())		{			case 1:			OMedia3DShapeConverter::set_texture_conv_mode(omctxtconv_Ignore);			break;			case 2:			OMedia3DShapeConverter::set_texture_conv_mode(omctxtconv_ImportIfNotFound);			break;						case 3:			OMedia3DShapeConverter::set_texture_conv_mode(omctxtconv_Create);			break;						case 4:			OMedia3DShapeConverter::set_texture_conv_mode(omctxtconv_Replace);			break;					}			p = dynamic_cast<LStdPopupMenu*>(theDialog->FindPaneByID(32)); Assert_(p != nil);		switch(p->GetValue())		{			case 1:			OMedia3DShapeConverter::set_material_convert_mode(omc3dmconv_IgnoreMaterial);			break;			case 2:			OMedia3DShapeConverter::set_material_convert_mode(omc3dmconv_CreateNewMaterialIfNotFound);			break;						case 3:			OMedia3DShapeConverter::set_material_convert_mode(omc3dmconv_ExistingMaterialOnly);			break;						case 4:			OMedia3DShapeConverter::set_material_convert_mode(omc3dmconv_AlwaysCreateNewMaterial);			break;						case 5:			OMedia3DShapeConverter::set_material_convert_mode(omc3dmconv_ReplaceMaterial);			break;		}		p = dynamic_cast<LStdPopupMenu*>(theDialog->FindPaneByID(33)); Assert_(p != nil);		switch(p->GetValue())		{			case 1:			OMedia3DShapeConverter::set_object_convert_mode(omc3doconv_MergeObjects);			break;			case 2:			OMedia3DShapeConverter::set_object_convert_mode(omc3doconv_OneShapePerObject);			break;						case 3:			OMedia3DShapeConverter::set_object_convert_mode(omc3doconv_OneShapePerGroup);			break;		}		p = dynamic_cast<LStdPopupMenu*>(theDialog->FindPaneByID(34)); Assert_(p != nil);		switch(p->GetValue())		{			case 1:			OMedia3DShapeConverter::set_anim_conv_mode_mode(omc3danconv_Ignore);			break;			case 2:			OMedia3DShapeConverter::set_anim_conv_mode_mode(omc3danconv_ReplaceMorphAnimDef);			break;						case 3:			OMedia3DShapeConverter::set_anim_conv_mode_mode(omc3danconv_AlwaysCreateNewMorphAnimDef);			break;									case 4:			OMedia3DShapeConverter::set_anim_conv_mode_mode(omc3danconv_AddSequence);			break;					}				c = dynamic_cast<LStdControl*>(theDialog->FindPaneByID(10)); Assert_(c != nil);		if (c->GetValue()) OMedia3DShapeConverter::add_convert_flags(om3dcf_MergeNormals);		else OMedia3DShapeConverter::rem_convert_flags(om3dcf_MergeNormals);		c = dynamic_cast<LStdControl*>(theDialog->FindPaneByID(11)); Assert_(c != nil);		if (c->GetValue()) OMedia3DShapeConverter::add_convert_flags(om3dcf_MergeVerticesNormals);		else OMedia3DShapeConverter::rem_convert_flags(om3dcf_MergeVerticesNormals);		c = dynamic_cast<LStdControl*>(theDialog->FindPaneByID(12)); Assert_(c != nil);		if (c->GetValue()) OMedia3DShapeConverter::add_convert_flags(om3dcf_MergeIdenticalMaterials);		else OMedia3DShapeConverter::rem_convert_flags(om3dcf_MergeIdenticalMaterials);		c = dynamic_cast<LStdControl*>(theDialog->FindPaneByID(13)); Assert_(c != nil);		if (c->GetValue()) OMedia3DShapeConverter::add_convert_flags(om3dcf_OneMaterialPerTexture);		else OMedia3DShapeConverter::rem_convert_flags(om3dcf_OneMaterialPerTexture);				e  = dynamic_cast<LEditField*>(theDialog->FindPaneByID(14)); Assert_(e != nil);		e->GetDescriptor(lstr);					OMedia3DShapeConverter::set_new_material_prefix(LStr255toString(lstr));			e  = dynamic_cast<LEditField*>(theDialog->FindPaneByID(15)); Assert_(e != nil);		e->GetDescriptor(lstr);					OMedia3DShapeConverter::set_new_texture_prefix(LStr255toString(lstr));			c = dynamic_cast<LStdControl*>(theDialog->FindPaneByID(50)); Assert_(c != nil);		if (c->GetValue()) OMedia3DShapeConverter::set_world_conv_mode(omcworldconv_3DElement);		else OMedia3DShapeConverter::set_world_conv_mode(omcworldconv_None);	}}pascal static Boolean Nav3DShapeFileFilter(AEDesc *theItem, void *info, void *callBackUD, NavFilterModes filterMode){	FSSpec	*spec;	if (theItem->descriptorType!=typeFSS) return true;		NavFileOrFolderInfo	*finfo = (NavFileOrFolderInfo*)info;	if (finfo->isFolder) return true;	if (finfo->fileAndFolder.fileInfo.finderInfo.fdType=='TEXT') return true;		HLock((Handle)theItem->dataHandle);	spec = (FSSpec*)(*theItem->dataHandle);		int nlen = 	spec->name[0];	unsigned char *p = spec->name+1;		Boolean res = false;		if (nlen>4)	{		if ((p[nlen-1]=='f' || p[nlen-1]=='F') &&			(p[nlen-2]=='x' || p[nlen-2]=='X') &&			(p[nlen-3]=='d' || p[nlen-3]=='D') &&			(p[nlen-4]=='.')) res = true;		if ((p[nlen-1]=='e' || p[nlen-1]=='E') &&			(p[nlen-2]=='s' || p[nlen-2]=='S') &&			(p[nlen-3]=='a' || p[nlen-3]=='A') &&			(p[nlen-4]=='.')) res = true;		if ((p[nlen-1]=='i' || p[nlen-1]=='I') &&			(p[nlen-2]=='s' || p[nlen-2]=='S') &&			(p[nlen-3]=='x' || p[nlen-3]=='X') &&			(p[nlen-4]=='.')) res = true;	}	HUnlock((Handle)theItem->dataHandle);		return res;}void CDBDocument::import3DShape(FSSpec documentFSSpec){	OMediaFilePath	path;	OMediaMacRtgFilePath *rtgPath = (OMediaMacRtgFilePath*)path.getretarget();	string			name;	vector<omt_FSChunkID>::iterator ci;		rtgPath->fsspec = documentFSSpec;		OMediaFileStream	file;		try	{		file.setpath(&path);		file.open(omcfp_Read,false,false);		OMedia3DShape	*shape;				shape = omd_GETOBJECT(dbase,OMedia3DShape,								dbase->get_unique_chunkid(OMedia3DShape::db_type,baseID));				file>>shape;		name = prefixName;		name += Str255toString(documentFSSpec.name);				shape->set_chunk_name(checkFileExtension(name));		shape->set_modified(true);		shape->db_update();		shape->get_database()->close_chunk();		// To force size to be updated		shape->db_unlock();				for(ci=OMedia3DShapeConverter::related_textures.begin();			ci!=OMedia3DShapeConverter::related_textures.end();			ci++)		{			OMediaCanvas *canv;			quietCloseEditorFor(OMediaCanvas::db_type,(*ci));						canv = omd_GETOBJECT(dbase,OMediaCanvas,(*ci));			canv->set_2Dsubdivision(CanvImport_subdiv_w,CanvImport_subdiv_h);			canv->set_filtering(CanvImport_mag_filtering,CanvImport_min_filtering);			canv->set_internal_pixel_format(CanvImport_internal_pixel_format);			canv->db_update();			canv->db_unlock();					}		for(ci=OMedia3DShapeConverter::related_materials.begin();			ci!=OMedia3DShapeConverter::related_materials.end();			ci++)		{			OMedia3DMaterial *mat;			quietCloseEditorFor(OMedia3DMaterial::db_type,(*ci));						mat = omd_GETOBJECT(dbase,OMedia3DMaterial,(*ci));			mat->db_update();			mat->db_unlock();		}		for(ci=OMedia3DShapeConverter::related_worldelements.begin();			ci!=OMedia3DShapeConverter::related_worldelements.end();			ci++)		{			OMediaElement *el;			quietCloseEditorFor(OMediaElement::db_type,(*ci));						el = omd_GETOBJECT(dbase,OMediaElement,(*ci));			el->db_update();			el->db_unlock();		}								file.close();		}	catch(...)	{		// +++ Should display an error message	}}//-----------------------------------------------------------------------------void CDBDocument::doImportFiles(int mode){	PP_StandardDialogs::LFileChooser	chooser;	NavDialogOptions*	options = chooser.GetDialogOptions();		if (mode==1)		chooser.SetObjectFilterProc(NavCanvasFileFilter);	else if (mode==2)		chooser.SetObjectFilterProc(Nav3DShapeFileFilter);	else if (mode==3)		chooser.SetObjectFilterProc(NavSoundFileFilter);		if (options != nil) 	{		options->dialogOptionFlags =	kNavDefaultNavDlogOptions										| kNavSelectAllReadableItem										| kNavAllowMultipleFiles;	}	if (chooser.AskOpenFile(LFileTypeList(fileTypes_All))) 	{		AEDescList		docList;    	OSErr           anErr = noErr;    		chooser.GetFileDescList(docList);        long    count;                anErr = AECountItems(&docList, &count);        // Set up index for file list        if (anErr == noErr)		{            long index;                        for(index = 1; index <= count; index++)            {                AEKeyword   theKeyword;                DescType    actualType;                Size        actualSize;                FSSpec      documentFSSpec;                                // Get a pointer to selected file                anErr = AEGetNthPtr(&docList, index,                                    typeFSS, &theKeyword,                                    &actualType,&documentFSSpec,                                    sizeof(documentFSSpec),                                    &actualSize);                if (anErr == noErr)                {                	switch(mode)                	{                		case 1:                		importCanvas(documentFSSpec);                		break;                		                		case 2:                		import3DShape(documentFSSpec);                		break;                		                		case 3:                		importSound(documentFSSpec);                		break;                		                		case 4:                		importCustom(documentFSSpec);                		break;                	}                                }            }		}				}}