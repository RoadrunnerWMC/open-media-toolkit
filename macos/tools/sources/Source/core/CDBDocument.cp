/*****************************************************************        O P E N      M E D I A     T O O L K I T              V2.5             Copyright Yves Schmid 1996-2003         See www.garagecube.com for more informations about this library.                Author(s): Yves Schmid         OMT is provided under LGPL:           This library is free software; you can redistribute it and/or          modify it under the terms of the GNU Lesser General Public          License as published by the Free Software Foundation; either          version 2.1 of the License, or (at your option) any later version.          This library is distributed in the hope that it will be useful,          but WITHOUT ANY WARRANTY; without even the implied warranty of          MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU          Lesser General Public License for more details.          You should have received a copy of the GNU Lesser General Public          License along with this library; if not, write to the Free Software          Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA          The full text of the license can be found in lgpl.txt          ******************************************************************/#include "CDBDocument.h"#include "CDocumentApp.h"#include "ExtraDefs.h"#include <LFile.h>#include <LPlaceHolder.h>#include <LPrintout.h>#include <LString.h>#include <LWindow.h>#include <PP_Messages.h>#include <UMemoryMgr.h>#include <UResourceMgr.h>#include <UWindows.h>#include "AppConstants.h"#include "LDBHierTable.h"#include "CCanvasEditor.h"#include "CSoundEditor.h"#include "CMaterialEditor.h"#include "C3DShapeEditor.h"#include "CWorldElementEditor.h"#ifdef support_HOMERE_MAP#include "CHomereWorldMapEditor.h"#endif#include "OMedia3DShape.h"#include "OMediaCanvas.h"#include "OMediaSound.h"#include "OMedia3DMaterial.h"#include "LMsgEditField.h"#include "LTextColumn.h"#include "OMediaElement.h"#include "OMedia3DMorphAnim.h"#include "OMedia3DShapeAnim.h"#include "OMediaCanvasAnim.h"#include "OMediaAnim.h"#include "OMediaString.h"#include <string>bool CDBBlock::sortByDesc = false;// ---------------------------------------------------------------------------------//	¥ CDBDocument										[public]// ---------------------------------------------------------------------------------//	ConstructorCDBDocument::CDBDocument(	LCommander*		inSuper,	FSSpec*			inFileSpec)	: LSingleDoc(inSuper){	LMsgEditField	*filterEditField;		// Create window for our document.	mWindow = LWindow::CreateWindow(PPob_DBDocWindow, this );	ThrowIfNil_(mWindow);	mWindow->MoveWindowBy(4,4);	mWindow->SetThemeData(kThemeBackgroundPlacard, kThemeBackgroundPlacard,							 kThemeTextColorDialogActive, kThemeTextColorDialogInactive);		mHierarchyView = dynamic_cast<LDBHierTable*>(mWindow->FindPaneByID(kHierarchyView));	Assert_(mHierarchyView != nil);	mHierarchyView->myDocument = this;	mWindow->SetLatentSub(mHierarchyView);	sortPopup = dynamic_cast<LStdPopupMenu*>(mWindow->FindPaneByID(kSortPopup));	Assert_(sortPopup != nil);	sortPopup->AddListener(this);		filterEditField = dynamic_cast<LMsgEditField*>(mWindow->FindPaneByID(kFilterStringField));	Assert_(filterEditField != nil);	filterEditField->AddListener(this);			mFileDesignator = nil;		if (inFileSpec == nil) 	{		NameNewDoc();				// Set the name of new window.					// Proxy icon for untitled window is based on the			// creator and type the file will have if saved				::SetWindowProxyCreatorAndType(mWindow->GetMacWindow(), kApplicationCreator,											GetFileType(), kOnSystemDisk);				// I generate an empty database:				dbstream = CTempStream::createTempStream();		dbase = new OMediaDataBase(dbstream);													mHierarchyView->dbase = dbase;		mHierarchyView->makeCollapsedMap(true);			} 	else 	{		OpenFile(*inFileSpec);		// Display contents of file in window.	}		// Build view	updateInfoCaptions();	// Make the window visible.		mWindow->Show();	StartIdling();}// ---------------------------------------------------------------------------------// ---------------------------------------------------------------------------------//	¥ ~CDBDocument									[public, virtual]// ---------------------------------------------------------------------------------//	DestructorCDBDocument::~CDBDocument(){	try 	{		TakeOffDuty();				if ((mFile != nil) && (mFileDesignator != nil)) 		{			mFile->CloseDataFork();			mFile->CloseResourceFork();			mFileDesignator->CompleteSave();		}			}			catch (...) { }		delete mFileDesignator;		// Close editors		while(editors.size())	{		dbeditor_Map::iterator mi;				mi = editors.begin();		(*mi).second->Close();	}}// ---------------------------------------------------------------------------//	¥ NameNewDoc										[protected, virtual]// ---------------------------------------------------------------------------//	Name a new, untitled document window////	Untitled windows start with "untitled", then "untitled 2",//	"untitled 3", etc. Old numbers are reused, so there won't be//	gaps in the numbering. This follows Apple's HIG.////	This routine uses a STR# resource to store the "untitled" string,//	which can be localized to different languages. The first string//	is "untitled" and the second is "untitled " (trailing space),//	which is used when appending a number to the name.voidCDBDocument::NameNewDoc(){								// Start with the default name ("untitled")	LStr255		name(STRx_DefaultDocumentTitle, DefaultDocumentTitle_Untitled);			// Check if an existing window has this name. If so,		// append a count ("untitled 2"). Keep incrementing the		// count until we find a unique name.			long	num = 1;	while (UWindows::FindNamedWindow(name) != nil) {						// "untitled " (note trailing space)		name.Assign(STRx_DefaultDocumentTitle, DefaultDocumentTitle_UntitledX);		name += (++num);				// Increment and append count to name	}				mWindow->SetDescriptor(name);		// Finally, set window title}// ---------------------------------------------------------------------------------//	¥ OpenFile											[protected, virtual]// ---------------------------------------------------------------------------------//	Open the specified filevoid CDBDocument::OpenFile(	FSSpec&		inFileSpec){	FSSpec shit = inFileSpec;	mFile = nil;			// Create a new File object, read the entire File contents,		//  put the contents into the text view, and set the Window		//  title to the name of the File.		// We don't close the file (until mFile is deleted) so we		//  can prevent others from modifying the file.			try 	{		StDeleter<LFile>	theFile(new LFile(inFileSpec));				theFile->OpenDataFork(fsRdWrPerm);				dbstream = CTempStream::createTempStream();		CTempStream::readToTempStream(theFile, dbstream);		dbase = new OMediaDataBase(dbstream);		mHierarchyView->dbase = dbase;				mWindow->SetDescriptor(inFileSpec.name);		mIsSpecified = true;					// Associate window proxy with the file. Docs say that			// we need to save/restore the port around this call.				StGrafPortSaver	savePort;		::SetWindowProxyFSSpec(mWindow->GetMacWindow(), &inFileSpec);				mFile = theFile.Release();			mHierarchyView->makeCollapsedMap(true);		mHierarchyView->rebuildTable();		updateInfoCaptions();		}		catch (LException& inErr) 	{			// If the 32K limit of TextEdit is hit, do not rethrow here.			// Instead, this would be a good place to notify the user of			// the situation.						if (inErr.GetErrorCode() != err_32kLimit) {			throw;		}	}}// ---------------------------------------------------------------------------------//	¥ IsModified										[public, virtual]// ---------------------------------------------------------------------------------//	Return whether the Document is has changed since the last saveBooleanCDBDocument::IsModified(){		// Document has changed if the text view is dirty.		// Set Toolbox window "modified" state, which affects how		// the proxy icon draws. When the document has no specified file,		// the window is considered modified even if the text isn't.		::SetWindowModified(mWindow->GetMacWindow(), (mIsModified or not mIsSpecified));		return mIsModified;}// ---------------------------------------------------------------------------------//	¥ DoAESave											[public, virtual]// ---------------------------------------------------------------------------------//	Save Document in the specified file with the specified file type////	If file type is fileType_Default, use the normal file type for//	this documentvoidCDBDocument::DoAESave(	FSSpec&		inFileSpec,	OSType		inFileType ){		// Delete the existing file object.		// Note: this does nothing to the actual file on disk.	delete mFile;	mFile = nil;			// Make a new file object.	mFile = new LFile(inFileSpec);			// Get the proper file type.	OSType	theFileType = GetFileType();	if (inFileType != fileType_Default) 	{		theFileType = inFileType;	}			// Make new file on disk.	mFile->CreateNewFile(kApplicationCreator, theFileType);	mFile->OpenDataFork(fsRdWrPerm);	mFile->OpenResourceFork(fsRdWrPerm);			// Write out the data.	DoSave();		// Change window title to reflect the new name.	mWindow->SetDescriptor(inFileSpec.name);		// Document now has a specified file.	mIsSpecified = true;					// Associate window proxy with the file. Docs say that			// we need to save/restore the port around this call.			StGrafPortSaver	savePort;	::SetWindowProxyFSSpec(mWindow->GetMacWindow(), &inFileSpec);}// ---------------------------------------------------------------------------------//	¥ DoSave											[public, virtual]// ---------------------------------------------------------------------------------//	Save the entire Document to its associated File, which must already existvoidCDBDocument::DoSave(){	// Flush all database objects to stream		dbase->write_objects_all();	dbase->write_header();	dbstream->flush_buffer();	CTempStream::writeFromTempStream(mFile, dbstream);	// Saving makes doc clean.	SetModified(false);		// Make window proxy unmodified	::SetWindowModified(mWindow->GetMacWindow(), false);}// ---------------------------------------------------------------------------------//	¥ DoRevert											[public, virtual]// ---------------------------------------------------------------------------------//	Revert the Document to the last saved version on diskvoidCDBDocument::DoRevert(){	// Close editors		while(editors.size())	{		dbeditor_Map::iterator mi;				mi = editors.begin();		(*mi).second->Close();	}	// Assumes document is already open	delete dbase;	delete dbstream;		dbstream = CTempStream::createTempStream();	CTempStream::readToTempStream(mFile,dbstream);	dbase = new OMediaDataBase(dbstream);		mHierarchyView->dbase = dbase;				mHierarchyView->makeCollapsedMap(true);	mHierarchyView->rebuildTable();	updateInfoCaptions();	SetModified(false);}// ---------------------------------------------------------------------------//	¥ AskSaveAs														  [public]// ---------------------------------------------------------------------------//	Ask the user to save a Document and give it a name////	Returns false if the user cancels the operationBooleanCDBDocument::AskSaveAs(	FSSpec&		outFSSpec,	Boolean		inRecordIt){	Boolean		saveOK = false;	PP_StandardDialogs::LFileDesignator*	designator =								new PP_StandardDialogs::LFileDesignator;									designator->SetFileType( GetFileType() );		Str255	defaultName;	if (designator->AskDesignateFile(GetDescriptor(defaultName))) 	{				designator->GetFileSpec(outFSSpec);				if (designator->IsReplacing() && UsesFileSpec(outFSSpec)) 		{									// User chose to replace the file with									//   one of the same name. 												if (inRecordIt) {		// This is the same as a save				SendSelfAE(kAECoreSuite, kAESave, ExecuteAE_No);			}							// Same document is still open, so we don't need to complete				// the save. However, user may have selected different				// translation options, so we need to delete the original				// designator and store the new one.						delete mFileDesignator;			mFileDesignator = designator;							DoSave();				// Save data to disk			saveOK = true;					} else {					if (inRecordIt) {		// Recording for AppleScript				SendAESaveAs(outFSSpec, GetFileType(), ExecuteAE_No);			}						if (designator->IsReplacing()) {				ThrowIfOSErr_(::FSpDelete(&outFSSpec));			}												// Save data to new file. This also									//    closes the original file			DoAESave(outFSSpec, fileType_Default);						if (mFileDesignator != nil) {									// Complete save of original designator				mFileDesignator->CompleteSave();				delete mFileDesignator;			}												// Store new designator so we can									//   complete save when we close									//   the document			mFileDesignator = designator;						saveOK = true;		}	}		return saveOK;}// ---------------------------------------------------------------------------//	¥ GetFileType										[public, virtual]// ---------------------------------------------------------------------------//	Return the type (four character code) of the file used for saving//	the Document. Subclasses should override if they support saving files.OSTypeCDBDocument::GetFileType() const{	return ResType_OMTDOCUMENT;}// ---------------------------------------------------------------------------//	¥ FindCommandStatus									[public, virtual]// ---------------------------------------------------------------------------//	Override provided here for convenience.voidCDBDocument::FindCommandStatus(	CommandT		inCommand,	Boolean&		outEnabled,	Boolean&		outUsesMark,	UInt16&			outMark,	Str255			outName){	LSingleDoc::FindCommandStatus(inCommand, outEnabled, outUsesMark, outMark, outName);	}// ---------------------------------------------------------------------------//	¥ ObeyCommand										[public, virtual]// ---------------------------------------------------------------------------//	Override provided here for convenience.BooleanCDBDocument::ObeyCommand(	CommandT		inCommand,	void*			ioParam){	Boolean	cmdHandled = LSingleDoc::ObeyCommand(inCommand, ioParam);	return cmdHandled;}// ---------------------------------------------------------------------------//	¥ HasResourceFork									[static, public]// ---------------------------------------------------------------------------//	Given an FSSpec, determine if the file has a resource fork or not. Code//	gleaned from MoreFiles.boolCDBDocument::HasResourceFork(	const FSSpec&	inFile){	HParamBlockRec pb;		pb.fileParam.ioNamePtr		= (StringPtr)inFile.name;	pb.fileParam.ioVRefNum		= inFile.vRefNum;	pb.fileParam.ioFVersNum		= 0;	pb.fileParam.ioDirID		= inFile.parID;	pb.fileParam.ioFDirIndex	= 0;	OSErr err = ::PBHGetFInfoSync(&pb);	ThrowIfOSErr_(err);		return (pb.fileParam.ioFlRLgLen != 0);}// ---------------------------------------------------------------------------//	¥ HasResourceFork									[static, public]// ---------------------------------------------------------------------------//	Same as the above version, but takes an LFile object instead.boolCDBDocument::HasResourceFork(	const LFile&	inFile){	FSSpec	theSpec;	inFile.GetSpecifier(theSpec);		return HasResourceFork(theSpec);}// ---------------------------------------------------------------------------void CDBDocument::updateInfoCaptions(void){	LCaption	*nobjCap,*sizeCap;	nobjCap = dynamic_cast<LCaption*>(mWindow->FindPaneByID(kNObjectsCaption));	Assert_(nobjCap != nil);	sizeCap = dynamic_cast<LCaption*>(mWindow->FindPaneByID(kFileSizeCaption));	Assert_(sizeCap != nil);	Assert_(dbstream != nil);	Assert_(dbase != nil);		LStr255	str;	SInt32 siz,nobj;	// Compute Stream Size		siz = dbstream->getsize();	if (siz>1000)	{		str = siz/1000;		str += " KB";	}	else	{		str = siz;		str += " bytes";	}			sizeCap->SetDescriptor(str);		// Nobjects in databases		omt_ChunkTypeList	*tlist;		nobj = 0;		tlist = dbase->get_chunk_type_list();	for(omt_ChunkTypeList::iterator ti = tlist->begin();		ti!=tlist->end();		ti++)	{		nobj += (*ti).get_chunk_list()->size();	}	str = nobj;	str += (nobj>1)?" objects":" object";	nobjCap->SetDescriptor(str);}// ---------------------------------------------------------------------------LStr255 CDBDocument::chunkTypeToString(omt_ChunkType ct){	LStr255		str;	switch(ct)	{		case OMediaElement::db_type: str = "World Element"; break;		case OMedia3DShape::db_type: str = "3D Shape"; break;		case OMediaCanvas::db_type: str = "Canvas"; break;		case OMediaSound::db_type: str = "Sound"; break;		case OMedia3DMaterial::db_type: str = "3D Material"; break;			#ifdef support_HOMERE_MAP		case HomMap::db_type: str = "Homere World Map"; break;	#endif					default: str = "Binary";	}	str += " (";		str += (unsigned char)((ct>>24)&0xFF);	str += (unsigned char)((ct>>16)&0xFF);	str += (unsigned char)((ct>>8)&0xFF);	str += (unsigned char)((ct>>0)&0xFF);	str += ")";			return str;}// ---------------------------------------------------------------------------string	CDBDocument::LStr255toString(LStr255 pstr){	char cstr[256];	string str;			cstr[pstr.Length()] = 0;	memcpy(cstr,pstr.TextPtr(),pstr.Length());	str = cstr;	return str;}string	CDBDocument::Str255toString(Str255 pstr){	char cstr[256];	string str;			cstr[pstr[0]] = 0;	memcpy(cstr,pstr+1,pstr[0]);	str = cstr;	return str;}// ---------------------------------------------------------------------------void CDBDocument::quietCloseEditorFor(omt_ChunkType dtype, omt_FSChunkID did){	CDBBlock	bl;	bl.ctype = dtype;	bl.id = did;	// Close editor if required	dbeditor_Map::iterator	mi;	mi = editors.find(bl);	if (mi!=editors.end())	{			(*mi).second->quietClose = true;		delete (*mi).second;	}}void CDBDocument::objectWillDie(omt_ChunkType dtype, omt_FSChunkID did){	CDBBlock	bl;		bl.ctype = dtype;	bl.id = did;	objectWillDieRemoveDepencies(dtype,did);	// Close editor if required	dbeditor_Map::iterator	mi;	mi = editors.find(bl);	if (mi!=editors.end())	{		delete (*mi).second;	}}void CDBDocument::objectWillDieRemoveDepencies(omt_ChunkType dtype, omt_FSChunkID did){	dbeditor_Map::iterator	mi;	OMediaDBObject	*obj = NULL;		if (dbase->object_loaded(dtype,did))	{		obj = dbase->get_object(dtype,did);	}	// Inform editors		for(mi=editors.begin();		mi!=editors.end();		mi++)	{		(*mi).second->objectWillDie(dtype,did);		}		// Check material->canvas		if (dtype==OMediaCanvas::db_type && obj)	{		OMediaFSChunkTypeNode *node = dbase->get_chunk_type_node(OMedia3DMaterial::db_type);		omt_ChunkList::iterator ci;				if (node)				for(ci=node->get_chunk_list()->begin();			ci!=node->get_chunk_list()->end();			ci++)		{			if (dbase->object_loaded(OMedia3DMaterial::db_type,(*ci).id))			{				OMedia3DMaterial *mat = omd_GETOBJECT(dbase,OMedia3DMaterial,(*ci).id);				if (mat->get_texture()==(OMediaCanvas*)obj)				{					mat->set_texture(NULL);					mat->set_modified(true);				}								mat->db_unlock();						}		}		}	// Check shape->material		if (dtype==OMedia3DMaterial::db_type && obj)	{		OMediaFSChunkTypeNode *node = dbase->get_chunk_type_node(OMedia3DShape::db_type);		omt_ChunkList::iterator ci;				if (node)		for(ci=node->get_chunk_list()->begin();			ci!=node->get_chunk_list()->end();			ci++)		{			if (dbase->object_loaded(OMedia3DShape::db_type,(*ci).id))			{				OMedia3DShape *sh = omd_GETOBJECT(dbase,OMedia3DShape,(*ci).id);				omt_PolygonList::iterator pi;								sh->lock(omlf_Read|omlf_Write);				for(pi=sh->get_polygons()->begin();pi!=sh->get_polygons()->end();pi++)				{					if ((*pi).get_material()==(OMedia3DMaterial*)obj)					{						(*pi).set_material(NULL);						sh->set_modified(true);					}				}								sh->unlock();				sh->db_unlock();			}		}		}	// Check element->shape		if (dtype==OMedia3DShape::db_type && obj)	{		OMediaFSChunkTypeNode *node = dbase->get_chunk_type_node(OMediaElement::db_type);		omt_ChunkList::iterator ci;				if (node)		for(ci=node->get_chunk_list()->begin();			ci!=node->get_chunk_list()->end();			ci++)		{			if (dbase->object_loaded(OMediaElement::db_type,(*ci).id))			{				OMediaElement *el = omd_GETOBJECT(dbase,OMediaElement,(*ci).id);				el->unlink_shape_from_structure((OMedia3DShape*)obj);				el->db_unlock();			}		}		}		// element->animdef	if ((dtype==OMedia3DMorphAnimDef::db_type ||		dtype==OMedia3DShapeAnimDef::db_type ||		dtype==OMediaCanvasAnimDef::db_type||		dtype==OMediaAnimDef::db_type) && obj)	{		OMediaFSChunkTypeNode *node = dbase->get_chunk_type_node(OMediaElement::db_type);		omt_ChunkList::iterator ci;				if (node)		for(ci=node->get_chunk_list()->begin();			ci!=node->get_chunk_list()->end();			ci++)		{			if (dbase->object_loaded(OMediaElement::db_type,(*ci).id))			{				OMediaElement *el = omd_GETOBJECT(dbase,OMediaElement,(*ci).id);				el->unlink_animdef_from_structure((OMediaAnimDef*)obj);				el->db_unlock();			}		}		}		if (obj) obj->db_unlock();}void CDBDocument::objectRenamed(omt_ChunkType dtype, omt_FSChunkID did){	CDBBlock	bl;	dbeditor_Map::iterator	mi;		bl.ctype = dtype;	bl.id = did;	mi = editors.find(bl);	if (mi!=editors.end())	{		(*mi).second->setTitle();	}	// Inform editors		for(mi=editors.begin();		mi!=editors.end();		mi++)	{		(*mi).second->objectRenamed(dtype,did);		}}bool CDBDocument::canEditObjectType(omt_ChunkType dtype){	if (dtype==OMediaCanvas::db_type) return true;	if (dtype==OMediaSound::db_type) return true;		return false;}// ---------------------------------------------------------------------------bool CDBDocument::canEditSelection(){	cdbblock_Set 			selset;	cdbblock_Set::iterator 	si;		selectionToBlockSet(selset);		for(si=selset.begin();		si!=selset.end();		si++)	{		// At least one			if (canEditObjectType((*si).ctype)) return true;		}		return false;}// ---------------------------------------------------------------------------void CDBDocument::selectionToBlockSet(cdbblock_Set &blockSet){	STableCell 		icell,cell;	CDBBlock		dbblock;	CCellDBData		dbcell;	unsigned long	siz;	LDBHierTable	*table = mHierarchyView;	if (!table->hasSelection()) return;	for(icell = table->GetFirstSelectedCell();;)	{		TableIndexT	woRow = table->GetWideOpenIndex(icell.row);		STableCell	cell(woRow, icell.col);				table->GetCellData(cell, &dbcell, siz=sizeof(CCellDBData));				if (dbcell.isChunkTypeTitle)		{			OMediaFSChunkTypeNode	*tn;			omt_ChunkList			*cl;			omt_ChunkList::iterator	i;						tn = table->dbase->get_chunk_type_node(dbcell.ctype);			if (tn==NULL) continue;						cl = tn->get_chunk_list();			for(i=cl->begin(); i!=cl->end();i++)			{				dbblock.ctype = dbcell.ctype;				dbblock.id = (*i).id;				dbblock.desc = (*i).name;				blockSet.insert(blockSet.begin(),dbblock);			}		}		else		{			char cstr[256];						cstr[dbcell.desc[0]] =0;			memcpy(cstr,dbcell.desc+1,dbcell.desc[0]);					dbblock.ctype = dbcell.ctype;			dbblock.id = dbcell.id;			dbblock.desc = cstr;			blockSet.insert(blockSet.begin(),dbblock);		}			if (!table->GetNextSelectedCell(icell)) break;	}}// ---------------------------------------------------------------------------void CDBDocument::ListenToMessage(							MessageT		inMessage,							void*			ioParam){	switch(inMessage)	{		case msgSortPopupChanged:		switch (sortPopup->GetValue())		{			case 1:			mHierarchyView->changeSortMode(sortcell_Name);			break;						case 2:			mHierarchyView->changeSortMode(sortcell_Size);			break;						case 3:			mHierarchyView->changeSortMode(sortcell_ID);			break;		}		break;					case msgMsgEditFieldChanged:		{			LMsgEditField *txt = (LMsgEditField*)ioParam;			Str255		ptr;						txt->GetDescriptor(ptr);						mHierarchyView->applyFilter(ptr);		}		break;	}}// ---------------------------------------------------------------------------MessageT CDBDocument::AskForRename(LCommander*	inSuper,									ResIDT			inDialogID,									string			&name){	StDialogHandler	theHandler(inDialogID, inSuper);	LWindow*		theDialog = theHandler.GetDialog();	LEditField		*ef;	LStr255			pstr;	theDialog->SetThemeData(kThemeBackgroundPlacard, kThemeBackgroundPlacard,							 kThemeTextColorDialogActive, kThemeTextColorDialogInactive);	ef = dynamic_cast<LEditField*>(theDialog->FindPaneByID(10));	theDialog->SetLatentSub(ef);	ef->SetDescriptor(pstr=name.c_str());	ef->SelectAll();		theDialog->Show();	Boolean		entryOK = false;	MessageT	hitMessage;	for(;;)	{		hitMessage = theHandler.DoDialog();		if (hitMessage!=msg_Nothing) break;	}		ef->GetDescriptor(pstr);	name = Str255toString(pstr);		return hitMessage;}// ---------------------------------------------------------------------------void CDBDocument::SpendTime( const EventRecord& inMacEvent ){	for(dbeditor_Map::iterator mi=editors.begin();		mi!=editors.end();		mi++)	{		if ((*mi).second->window==NULL)		{			delete (*mi).second;			break;		}		}}// ---------------------------------------------------------------------------void CDBDocument::edit(omt_ChunkType type, omt_FSChunkID id){	dbeditor_Map::iterator	mi;	CAbstractEditor			*ed;	CDBBlock				bl;		if (!dbase->object_exists(type,id)) return;		bl.ctype = type;	bl.id = id;	// Is editor already open ?		mi = editors.find(bl);	if (mi!=editors.end())	{		// Just bring it to front				ed = (*mi).second;		if (ed->window)		{			ed->window->Select();			return;		}				delete ed;	}		switch(type)	{		case OMediaCanvas::db_type:		new CCanvasEditor(id,this);		break;		case OMediaSound::db_type:		new CSoundEditor(id,this);		break;				case OMedia3DMaterial::db_type:		new CMaterialEditor(id,this);		break;				case OMedia3DShape::db_type:		new C3DShapeEditor(id,this);		break;				case OMediaElement::db_type:		new CWorldElementEditor(id,this);		break;#ifdef support_HOMERE_MAP				case HomMap::db_type:		new CHomereWorldMapEditor(id,this);		break;#endif			}}// ---------------------------------------------------------------------------bool CDBDocument::pickObject(LWindow *superwin, omt_ChunkType type, omt_FSChunkID &id){	StDialogHandler	theHandler(1103, superwin);	LWindow*		theDialog = theHandler.GetDialog();	LStr255			lstr;	LStdButton		*b;	omt_ChunkList	*clist;	OMediaFSChunkTypeNode	*tn;	vector<CDBBlock>		blocks;	CDBBlock				block;	LTextColumn				*tc;	string					str;	theDialog->SetThemeData(kThemeBackgroundPlacard, kThemeBackgroundPlacard,							 kThemeTextColorDialogActive, kThemeTextColorDialogInactive);	lstr = "\pChoose ";	lstr += chunkTypeToString(type);	theDialog->SetDescriptor(lstr);	tc = dynamic_cast<LTextColumn*>(theDialog->FindPaneByID(10));	clist = NULL;	tn = dbase->get_chunk_type_node(type);	if (tn) 	{		clist = tn->get_chunk_list();		if (clist->size()==0) clist = NULL;	}	if (clist)	{		vector<CDBBlock>::iterator bi;			omt_ChunkList::iterator ci;				block.ctype = type;				for(ci=clist->begin();			ci!=clist->end();			ci++)		{			block.id = (*ci).id;			block.desc = (*ci).name;			blocks.push_back(block);		}				CDBBlock::sortByDesc = true;		sort(blocks.begin(),blocks.end());				CDBBlock::sortByDesc = false;		STableCell	cell(1, 1);				tc->InsertRows(blocks.size(), 0, nil, 0, Refresh_No);				for(bi=blocks.begin();			bi!=blocks.end();			bi++)		{					cell.row = (bi-blocks.begin()) + 1;					str = omd_L2STR((*bi).id);			if (str.size()==5) str = " "+omd_L2STR((*bi).id);			else if (str.size()==4) str = "  "+omd_L2STR((*bi).id);			else if (str.size()==3) str = "   "+omd_L2STR((*bi).id);			else if (str.size()==2) str = "    "+omd_L2STR((*bi).id);			else if (str.size()==1) str = "     "+omd_L2STR((*bi).id);						str += "        ";								str += ((*bi).desc.size()==0)?"Untitled":(*bi).desc;						tc->SetCellData(cell, str.c_str(), str.size());						if ((*bi).id==id) 			{				tc->SelectCell(cell);				tc->ScrollCellIntoFrame(cell);			}		}				}	else	{		b = dynamic_cast<LStdButton*>(theDialog->FindPaneByID(2));		b->Disable();	}	tc->AddListener(&theHandler);	theDialog->Show();	Boolean		entryOK = false;	MessageT	hitMessage;	for(;;)	{		hitMessage = theHandler.DoDialog();		if (hitMessage!=msg_Nothing) break;	}			if (hitMessage==msg_OK && clist!=NULL)	{		STableCell cell = tc->GetFirstSelectedCell();				if (cell.row==0) return false;				id = blocks[cell.row-1].id;			return true;	}		return false;}// ---------------------------------------------------------------------------void CDBDocument::create(){	StDialogHandler	theHandler(1112, mWindow);	LWindow*		theDialog = theHandler.GetDialog();	LStr255			lstr;	LStdButton		*b;	LTextColumn				*tc;	string					str;	theDialog->SetThemeData(kThemeBackgroundPlacard, kThemeBackgroundPlacard,							 kThemeTextColorDialogActive, kThemeTextColorDialogInactive);	tc = dynamic_cast<LTextColumn*>(theDialog->FindPaneByID(10));	if (CDocumentApp::createObjectList.size())	{		vector<CCreateObjectDef>::iterator	di;			STableCell	cell(1, 1);				tc->InsertRows(CDocumentApp::createObjectList.size(), 0, nil, 0, Refresh_No);				for(di=CDocumentApp::createObjectList.begin();			di!=CDocumentApp::createObjectList.end();			di++)		{					cell.row = (di-CDocumentApp::createObjectList.begin()) + 1;					str = (*di).description;						tc->SetCellData(cell, str.c_str(), str.size());						if (cell.row==1) tc->SelectCell(cell);		}				}	else	{		b = dynamic_cast<LStdButton*>(theDialog->FindPaneByID(2));		b->Disable();	}	tc->AddListener(&theHandler);	theDialog->Show();	Boolean		entryOK = false;	MessageT	hitMessage;	for(;;)	{		hitMessage = theHandler.DoDialog();		if (hitMessage!=msg_Nothing) break;	}			if (hitMessage==msg_OK)	{		STableCell cell = tc->GetFirstSelectedCell();				if (cell.row!=0)		{								LEditField		*ef;			Str255			pstr;			omt_FSChunkID	ckid;			omt_ChunkType	cktype;			OMediaDBObject	*obj;			string			name;						cktype = CDocumentApp::createObjectList[cell.row-1].objectType;					ef = dynamic_cast<LEditField*>(theDialog->FindPaneByID(11));			ef->GetDescriptor(pstr);			name = Str255toString(pstr);			ef = dynamic_cast<LEditField*>(theDialog->FindPaneByID(12));			ef->GetDescriptor(pstr);			ckid = omd_STR2L(Str255toString(pstr));							obj = dbase->get_object(cktype,dbase->get_unique_chunkid(cktype,ckid));			obj->set_chunk_name(name);			obj->set_modified();			obj->db_update();			obj->db_unlock();			mHierarchyView->rebuildTable();			updateInfoCaptions();			SetModified(true);		}	}}