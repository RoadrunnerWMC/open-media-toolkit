/*****************************************************************        O P E N      M E D I A     T O O L K I T              V2.5             Copyright Yves Schmid 1996-2003         See www.garagecube.com for more informations about this library.                Author(s): Yves Schmid         OMT is provided under LGPL:           This library is free software; you can redistribute it and/or          modify it under the terms of the GNU Lesser General Public          License as published by the Free Software Foundation; either          version 2.1 of the License, or (at your option) any later version.          This library is distributed in the hope that it will be useful,          but WITHOUT ANY WARRANTY; without even the implied warranty of          MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU          Lesser General Public License for more details.          You should have received a copy of the GNU Lesser General Public          License along with this library; if not, write to the Free Software          Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA          The full text of the license can be found in lgpl.txt          ******************************************************************/#include "AppConstants.h"#include "LOMTWorldView.h"#include "UEventMgr.h"#include "OMediaPickRequest.h"LOMTWorldView::LOMTWorldView(LStream*		inStream):LOMTViewPort(inStream){	world = NULL;	layer = NULL;	mouseRotateShape = NULL;	light = NULL;	vp_distance = - 100;	view_Mode = CENTRED_VIEWLIGHT;	motionSpeed = 2.0f;}LOMTWorldView::~LOMTWorldView(){	delete world;}void LOMTWorldView::prepare(LOMTWindow *window){	OMediaFARGBColor	argb;	LOMTViewPort::prepare(window);		world = new OMediaWorld;	viewport->link(world);		layer = new OMediaLayer;	layer->link(world);	layer->add_flags(omlayerf_ClearColor);	layer->set_far_clip(30000);	layer->set_near_clip(1);	argb.set(1,0,0,0);	layer->set_clear_color(argb);			layer->set_light_global_ambient(argb);	axisLight.rotate(omc3daxis_X,-omd_Deg2Angle(20));	axisLight.rotate(omc3daxis_Y,omd_Deg2Angle(20));	light = new OMediaLight;	light->link(world);	light->set_light_type(omclt_Directional);}void LOMTWorldView::MouseDrag(const Point& p){	if (view_Mode==CENTRED_VIEW ||		view_Mode==CENTRED_VIEWLIGHT)	{		if ((UEventMgr::GetKeyModifiers()&shiftKey)==0)		{				axisShape.rotate(omc3daxis_Y, omd_Deg2Angle(2)*p.h);			axisShape.rotate(omc3daxis_X, omd_Deg2Angle(2)*p.v);			if (view_Mode==CENTRED_VIEWLIGHT)			{				axisLight.rotate(omc3daxis_Y, omd_Deg2Angle(2)*p.h);				axisLight.rotate(omc3daxis_X, omd_Deg2Angle(2)*p.v);			}		}		else			vp_distance -= p.v;	}	else	{		float sv = p.v * -motionSpeed;		float sh = p.h * motionSpeed;		if ((UEventMgr::GetKeyModifiers()&controlKey)!=0)		{			viewport->move(axisShape.get_axis(omc3daxis_Y).x * sv,							axisShape.get_axis(omc3daxis_Y).y * sv,							axisShape.get_axis(omc3daxis_Y).z * sv);			viewport->move(axisShape.get_axis(omc3daxis_X).x * sh,							axisShape.get_axis(omc3daxis_X).y * sh,							axisShape.get_axis(omc3daxis_X).z * sh);		}		else if ((UEventMgr::GetKeyModifiers()&shiftKey)!=0)		{			viewport->move(axisShape.get_axis(omc3daxis_Z).x * sv,							axisShape.get_axis(omc3daxis_Z).y * sv,							axisShape.get_axis(omc3daxis_Z).z * sv);			viewport->move(axisShape.get_axis(omc3daxis_X).x * sh,							axisShape.get_axis(omc3daxis_X).y * sh,							axisShape.get_axis(omc3daxis_X).z * sh);		}		else if ((UEventMgr::GetKeyModifiers()&optionKey)!=0)		{			axisShape.rotate(omc3daxis_Z, omd_Deg2Angle(1)*p.h);			axisShape.rotate(omc3daxis_X, omd_Deg2Angle(1)*p.v);		}		else		{			axisShape.rotate(omc3daxis_Y, omd_Deg2Angle(1)*p.h);			axisShape.rotate(omc3daxis_X, omd_Deg2Angle(1)*p.v);		}	}	DrawSelf();}void LOMTWorldView::ClickSelf(const SMouseDownEvent&	inMouseDown ){	LOMTViewPort::ClickSelf(inMouseDown);	BroadcastMessage(msgViewPortChanged,this);}void LOMTWorldView::UpdateViewport(){	if (view_Mode==CENTRED_VIEW ||		view_Mode==CENTRED_VIEWLIGHT)	{		OMedia3DShape *cSh = NULL;			if (mouseRotateShape)			cSh = mouseRotateShape->get_shape();			if (view_Mode==CENTRED_VIEWLIGHT) light->set_angle(axisLight);			viewport->set_angle(axisShape);		viewport->place(axisShape.get_axis(omc3daxis_Z).x * vp_distance,						axisShape.get_axis(omc3daxis_Z).y * vp_distance,						axisShape.get_axis(omc3daxis_Z).z * vp_distance);		if (cSh)			viewport->move(cSh->get_vcenterx(),cSh->get_vcentery(),cSh->get_vcenterz());	}	else	{		viewport->set_angle(axisShape);		}}void LOMTWorldView::DrawSelf(){	UpdateViewport();	LOMTViewPort::DrawSelf();}void LOMTWorldView::set_view_mode(LOMWorldViewMode vm){	view_Mode = vm;		if (view_Mode==CENTRED_VIEW ||		view_Mode==CENTRED_VIEWLIGHT)	{			axisShape.reset_axis();		axisLight.reset_axis();	}		UpdateViewport();	Refresh();}