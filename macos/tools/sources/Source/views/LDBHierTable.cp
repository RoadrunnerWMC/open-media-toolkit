/*****************************************************************        O P E N      M E D I A     T O O L K I T              V2.5             Copyright Yves Schmid 1996-2003         See www.garagecube.com for more informations about this library.                Author(s): Yves Schmid         OMT is provided under LGPL:           This library is free software; you can redistribute it and/or          modify it under the terms of the GNU Lesser General Public          License as published by the Free Software Foundation; either          version 2.1 of the License, or (at your option) any later version.          This library is distributed in the hope that it will be useful,          but WITHOUT ANY WARRANTY; without even the implied warranty of          MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU          Lesser General Public License for more details.          You should have received a copy of the GNU Lesser General Public          License along with this library; if not, write to the Free Software          Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA          The full text of the license can be found in lgpl.txt          ******************************************************************/#include "LDBHierTable.h"#include "LTableMonoGeometry.h"#include "LMyTableArrayStorage.h"#include "LTableMultiRowSelector.h"#include "CDBDocument.h"#include "CDBClipboard.h"#include "AppConstants.h"#include "CCanvasEditor.h"#include "CSoundEditor.h"#include "CMaterialEditor.h"#include "OMediaCanvas.h"#include "OMediaSound.h"#include "OMedia3DMaterial.h"#include <map>const int CELL_MAXWIDTH = 1280;CCellDBSortMode	CCellDBData::sortMode;LDBHierTable::LDBHierTable( LStream* inStream ):LTextHierTable(inStream){	dbase = NULL;	mParentTextTraits	= 134;	mLeafTextTraits		= 135;	mFirstIndent		= 20;	mLevelIndent		= 10;	sortMode			= sortcell_Name;		SetTableGeometry(new LTableMonoGeometry(this,CELL_MAXWIDTH,16));	SetTableStorage(new LMyTableArrayStorage(this,sizeof(CCellDBData)));	// 0==variable datasize per cell	SetTableSelector(new LTableMultiRowSelector(this) );}						LDBHierTable::~LDBHierTable(){}void LDBHierTable::clearTable(){	RemoveAllRows(true);	delete mTableStorage;	mTableStorage = NULL;	SetTableStorage(new LMyTableArrayStorage(this,sizeof(CCellDBData)));	// 0==variable datasize per cell}void LDBHierTable::makeCollapsedMap(bool build){	TableIndexT			rows,cols,i;	CCellDBData			typecell;	UInt32				siz;		GetTableSize(rows,cols);		int nodes = mCollapsableTree->CountNodes();		if (build)	{		omt_ChunkTypeList	*tlist;		tlist = dbase->get_chunk_type_list();		for(omt_ChunkTypeList::iterator ti = tlist->begin();			ti!=tlist->end();			ti++)		{			collMap[(*ti).get_chunk_type()] = true;		}	}	else	{		for(i=1;i<=nodes;i++)		{			if (mCollapsableTree->IsCollapsable(i))			{				siz = sizeof(CCellDBData);										((LTableArrayStorage*)mTableStorage)->GetCellDataByIndex(i,&typecell,siz);								if (!typecell.isChunkTypeTitle) return;								collMap[typecell.ctype] = !mCollapsableTree->IsExpanded(i);			}					}			}		}void LDBHierTable::rebuildTable(){	CCellDBData			dbcell;	list<CCellDBData>	celltypelist;	omt_ChunkTypeList	*tlist;	list<CCellDBData>::iterator ci;	Assert_(dbase != nil);	// Save collapsed flags		makeCollapsedMap();				// First build the chunk type list	clearTable();	SetDeferAdjustment(true);	InsertCols(1,0,0,0,true);	// Create the type list	LStr255			str;	unsigned char	*pstr;	tlist = dbase->get_chunk_type_list();	for(omt_ChunkTypeList::iterator ti = tlist->begin();		ti!=tlist->end();		ti++)	{		dbcell.isChunkTypeTitle = true;		dbcell.ctype = (*ti).get_chunk_type();			dbcell.size = computeTotalSizeChunkType(dbcell.ctype);				str = CDBDocument::chunkTypeToString(dbcell.ctype);		pstr = str;		memcpy(dbcell.desc,pstr,sizeof(Str255));				celltypelist.push_back(dbcell);	}	// Sort list types	CCellDBData::sortMode = sortcell_Name;	celltypelist.sort();		// Create table	TableIndexT idx=0;	omt_ChunkList	*ilist;	omt_ChunkList::iterator ii;	string s;	bool	parentNodeAdded;		for(ci=celltypelist.begin();ci!=celltypelist.end();ci++)	{			parentNodeAdded = false;				// Now generate the IDs, do not sort for now						ilist = (dbase->get_chunk_type_node((*ci).ctype))->get_chunk_list();		for(ii=ilist->begin();			ii!=ilist->end();			ii++)		{			if (filterString.length()!=0)			{				if ((*ii).name.length()==0) s = "Untitled"; else s = (*ii).name;							if (s.find(filterString)==string::npos) continue;						}						if (!parentNodeAdded)			{				parentNodeAdded = true;				idx = InsertSiblingRows(1,idx,&(*ci),sizeof(CCellDBData),true);					if (collMap[(*ci).ctype]) 				{					CollapseRow(idx);				}			}						pstr = str = (*ii).name.c_str();					dbcell.isChunkTypeTitle = false;			dbcell.ctype = (*ci).ctype;				dbcell.id = (*ii).id;			memcpy(dbcell.desc,pstr,sizeof(Str255));			dbcell.size = (*ii).size;			AddLastChildRow(idx,&dbcell,sizeof(CCellDBData));		}					}		// Now create the ID lists	SetDeferAdjustment(false);	sortCells();	Refresh();}long LDBHierTable::computeTotalSizeChunkType(omt_ChunkType ct){	long s = 0;	omt_ChunkList	*ilist;	omt_ChunkList::iterator ii;	ilist = dbase->get_chunk_type_node(ct)->get_chunk_list();	for(ii=ilist->begin();		ii!=ilist->end();		ii++)	{		s += (*ii).size;	}		return s;}void LDBHierTable::DrawCell(const STableCell&	inCell,							const Rect&			inLocalRect){	CCellDBData	dbcell;	TableIndexT	woRow = mCollapsableTree->GetWideOpenIndex(inCell.row);	UInt32		siz;	STableCell	woCell(woRow, inCell.col);	siz = sizeof(CCellDBData);	GetCellData(woCell, &dbcell, siz);	if (dbcell.isChunkTypeTitle)	{		RGBColor	rgb;		Rect		rect = inLocalRect;					// For title fill the back		if (CellIsSelected(inCell))		{			rgb.red = rgb.green = 0xBBBB;			rgb.blue = 0xFFFF;		}		else				rgb.red = rgb.green = rgb.blue = 0xEEEE;				rect.left += mFirstIndent-2;		rect.bottom -= 1;				::RGBForeColor(&rgb);		::PaintRect(&rect);		if (CellIsSelected(inCell))		{			rgb.red = rgb.green = 0xDDDD;			rgb.blue = 0xFFFF;		}		else				rgb.red = rgb.green = rgb.blue = 0xDDDD;				::RGBForeColor(&rgb);		::MoveTo(rect.left, rect.bottom);		::MacLineTo(rect.right, rect.bottom);	}	else	{		RGBColor	rgb;		Rect		rect = inLocalRect;					// For title fill the back		if (CellIsSelected(inCell))		{			rgb.red = rgb.green = 0xCCCC;			rgb.blue = 0xFFFF;					rect.left += mFirstIndent-2;					::RGBForeColor(&rgb);			::PaintRect(&rect);		}	}	DrawDropFlag(inCell, woRow);		UInt32	nestingLevel = mCollapsableTree->GetNestingLevel(woRow);	SInt16	tw;	LStr255	str;	SInt32  xoff;	if (dbcell.isChunkTypeTitle) xoff = 0;	else	{		xoff = 40;		str = dbcell.id;		str += " ";		tw = ::StringWidth(str);		if (tw>xoff) xoff = tw;		UTextTraits::SetPortTextTraits(136);				::MoveTo((SInt16) (inLocalRect.left + mFirstIndent + nestingLevel * mLevelIndent),				 (SInt16) (inLocalRect.bottom - 4));		::DrawString(str);	}	ResIDT	textTraitsID = mLeafTextTraits;	if (mCollapsableTree->IsCollapsable(woRow)) 	{		textTraitsID = mParentTextTraits;	}		UTextTraits::SetPortTextTraits(textTraitsID);	int	leftX;		leftX = inLocalRect.left + xoff + mFirstIndent + nestingLevel * mLevelIndent;		::MoveTo((SInt16) (leftX),			 (SInt16) (inLocalRect.bottom - 4));	::DrawString(dbcell.desc[0]==0?"\pUntitled":dbcell.desc);		leftX += ::StringWidth(dbcell.desc[0]==0?"\pUntitled":dbcell.desc);	str = sizeToStr(dbcell.size);	tw = ::StringWidth(str);		int s;		s = mFrameSize.width;		if (s>CELL_MAXWIDTH) s = CELL_MAXWIDTH;	if ((s-(tw+2))>leftX+10)	{		::MoveTo((SInt16) s-(tw+2),				 (SInt16) (inLocalRect.bottom - 4));				::DrawString(str);	}		}LStr255 LDBHierTable::sizeToStr(SInt32 siz){	LStr255	str;	if (siz>1000)	{		str = siz/1000;		str += " KB";	}	else	{		str = siz;		str += " bytes";	}	return str;}voidLDBHierTable::HiliteCell(	const STableCell&	inCell,	Boolean				inHilite){}void LDBHierTable::HiliteCellActively(								const STableCell&	inCell,								Boolean				inHilite){}																void LDBHierTable::HiliteCellInactively(								const STableCell&	inCell,								Boolean				inHilite){}void LDBHierTable::SelectionChanged(){	Refresh();}void LDBHierTable::changeSortMode(CCellDBSortMode newMode){	sortMode = newMode;	sortCells();}void LDBHierTable::sortCells(void){	vector<CCellDBData>	dblist;	TableIndexT			rows,cols,i,j;	CCellDBData			typecell,cell;	UInt32				siz,ncells;		CCellDBData::sortMode = sortMode;	SetDeferAdjustment(true);	GetTableSize(rows,cols);		int nodes = mCollapsableTree->CountNodes();		for(i=1;i<=nodes;i++)	{			if (mCollapsableTree->IsCollapsable(i))		{			dblist.erase(dblist.begin(),dblist.end());					siz = sizeof(CCellDBData);								((LTableArrayStorage*)mTableStorage)->GetCellDataByIndex(i,&typecell,siz);						ncells = mCollapsableTree->CountAllDescendents(i);			if (ncells==0) continue;						for(j=1;j<=ncells;j++)			{				siz = sizeof(CCellDBData);				((LMyTableArrayStorage*)mTableStorage)->GetCellDataByIndex(i+j,&cell,siz);								dblist.push_back(cell);			}						std::sort(dblist.begin(),dblist.end());			for(j=1;j<=ncells;j++)			{				CCellDBData	*cellp = &(dblist[j-1]);							siz = sizeof(CCellDBData);				((LMyTableArrayStorage*)mTableStorage)->SetCellDataByIndex(i+j,cellp,siz);							}		}				}						SetDeferAdjustment(false);	Refresh();}void LDBHierTable::applyFilter(Str255 &str){	char	cstr[256];	cstr[str[0]]=0;	memcpy(cstr,str+1,str[0]);		filterString = cstr;	SetDeferAdjustment(true);	rebuildTable();	SetDeferAdjustment(false);}void LDBHierTable::Click(SMouseDownEvent	&inMouseDown ){	// Call inherited for default behavior.	if (SwitchTarget(this)) LTableView::Click( inMouseDown );}// ---------------------------------------------------------------------------//	¥ ObeyCommand// ---------------------------------------------------------------------------//	Respond to Command messageBoolean LDBHierTable::ObeyCommand(	CommandT	inCommand,	void*		ioParam){	Boolean		cmdHandled = true;	switch (inCommand) 	{		case msg_TabSelect:		if (!IsEnabled()) 		{			cmdHandled = false;		}		break;		case cmd_Copy:		CDBClipboard::copy(this,myDocument);		break;		case cmd_Cut:		CDBClipboard::cut(this,myDocument);		break;		case cmd_Paste:		CDBClipboard::paste(this,myDocument);		break;		case cmd_Clear:		CDBClipboard::erase(this,myDocument);		break;		case cmd_SelectAll:		SelectAllCells();		break;				case cmd_Rename:		rename();		break;				case cmd_Edit:		edit();		break;		case cmd_Import:		myDocument->import();		break;		case cmd_Create:		myDocument->create();		break;		default:			cmdHandled = LCommander::ObeyCommand(inCommand, ioParam);			break;	}	return cmdHandled;}// ---------------------------------------------------------------------------//	¥ FindCommandStatus// ---------------------------------------------------------------------------//	Pass back the status of a Commandvoid LDBHierTable::FindCommandStatus(	CommandT	inCommand,	Boolean		&outEnabled,	Boolean		&outUsesMark,	UInt16		&outMark,	Str255		outName){	switch (inCommand) {		case cmd_SelectAll: 		{			outEnabled = (mCollapsableTree->CountNodes()>0);			break;		}				case cmd_Copy:		if (hasSelection()) outEnabled = true;		break;				case cmd_Rename:		if (oneIDSelected()) outEnabled = true;		break;		case cmd_Cut:		if (hasSelection()) outEnabled = true;		break;		case cmd_Paste:		if (CDBClipboard::hasData()) outEnabled = true;		break;		case cmd_Clear:		if (hasSelection()) outEnabled = true;		break;				case cmd_Edit:		if (myDocument->canEditSelection()) outEnabled = true;				break;				case cmd_Import:		outEnabled = true;		break;		case cmd_Create:		outEnabled = true;		break;		default:			LCommander::FindCommandStatus(inCommand, outEnabled,									outUsesMark, outMark, outName);			break;	}}// ---------------------------------------------------------------------------bool LDBHierTable::hasSelection(){	STableCell cell = GetFirstSelectedCell();	return (cell.row!=0);}int LDBHierTable::countSelection(){	int n=0;	STableCell cell = GetFirstSelectedCell();	if (cell.row==0) return 0;	for(;;)	{		n++;		if (!GetNextSelectedCell(cell)) break;	}	return n;}bool LDBHierTable::oneIDSelected(){	if (countSelection()!=1) return false;	CCellDBData		dbcell;	unsigned long	siz;	STableCell cell = GetFirstSelectedCell();	if (cell.row==0) return false;	TableIndexT	woRow = GetWideOpenIndex(cell.row);	STableCell	dcell(woRow, cell.col);		GetCellData(dcell, &dbcell, siz=sizeof(CCellDBData));	return (dbcell.isChunkTypeTitle==false);}// ---------------------------------------------------------------------------void LDBHierTable::rename(){	CCellDBData		dbcell;	unsigned long	siz;	string			str;	MessageT		res;	STableCell cell = GetFirstSelectedCell();	if (cell.row==0) return;	TableIndexT	woRow = GetWideOpenIndex(cell.row);	STableCell	dcell(woRow, cell.col);		GetCellData(dcell, &dbcell, siz=sizeof(CCellDBData));		dbase->get_chunk_name(dbcell.ctype,dbcell.id,str);		res = myDocument->AskForRename(this,1102,str);	if (res==msg_OK)	{		dbase->set_chunk_name(dbcell.ctype,dbcell.id,str);			myDocument->objectRenamed(dbcell.ctype,dbcell.id);		rebuildTable();		myDocument->SetModified(true);	}}// ---------------------------------------------------------------------------void LDBHierTable::edit(){	cdbblock_Set			selection;	myDocument->selectionToBlockSet(selection);		for(cdbblock_Set::iterator si = selection.begin();		si!=selection.end();		si++)	{		myDocument->edit((*si).ctype,(*si).id);	}}// ---------------------------------------------------------------------------void LDBHierTable::ClickSelf( const SMouseDownEvent& inMouseDown ){	if (sClickCount==1) LHierarchyTable::ClickSelf(inMouseDown);	else	{		edit();		}}