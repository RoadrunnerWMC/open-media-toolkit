/*****************************************************************        O P E N      M E D I A     T O O L K I T              V2.5             Copyright Yves Schmid 1996-2003         See www.garagecube.com for more informations about this library.                Author(s): Yves Schmid         OMT is provided under LGPL:           This library is free software; you can redistribute it and/or          modify it under the terms of the GNU Lesser General Public          License as published by the Free Software Foundation; either          version 2.1 of the License, or (at your option) any later version.          This library is distributed in the hope that it will be useful,          but WITHOUT ANY WARRANTY; without even the implied warranty of          MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU          Lesser General Public License for more details.          You should have received a copy of the GNU Lesser General Public          License along with this library; if not, write to the Free Software          Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA          The full text of the license can be found in lgpl.txt          ******************************************************************/#ifdef PowerPlant_PCH	#include PowerPlant_PCH#endif#include "LCanvasView.h"#include <LStream.h>#include <UDrawingState.h>#include "OMediaCanvas.h"PP_Begin_Namespace_PowerPlantLCanvasView::LCanvasView(LStream*	inStream)	: LView(inStream){	canvas = NULL;	gworld = NULL;	mRefreshAllWhenResized = false;}LCanvasView::~LCanvasView(){	if (canvas) 	{		canvas->db_unlock();		DisposeGWorld(gworld);	}}void LCanvasView::SetCanvas(OMediaCanvas *canvas){	if (this->canvas) 	{		this->canvas->db_unlock();		DisposeGWorld(gworld);	}		gworld = NULL;		this->canvas = canvas;	if (canvas) canvas->db_lock();		if (canvas != nil && (canvas->get_width()!=0 && canvas->get_height()!=0)) 	{		Rect				picRect;		OSErr				err;		OMediaCanvas		*backCanvas;		PixMapHandle 		macpixmap;		BitMap				*macbitmap;		unsigned long		*dpix,*bpix,rowbytes,x,y,w,h,wa,ha;		OMediaARGBColor		argb;		OMediaRect			orect;		w 	= canvas->get_width();		h 	= canvas->get_height();								backCanvas = new OMediaCanvas;		backCanvas->create(w,h);		backCanvas->lock(omlf_Read);				wa = w; if (wa%32) wa += 32;		ha = h; if (ha%32) ha += 32;				for(y=0;y<ha;y+=32)		for(x=0;x<wa;x+=32)		{			if ((y/32)&1)			{				if (((x/32)&1)!=0) argb.set(0xFFFF,0xFFFF,0xFFFF,0xFFFF);				else argb.set(0xFFFF,0xEEEE,0xEEEE,0xEEEE);			}			else			{				if (((x/32)&1)==0) argb.set(0xFFFF,0xFFFF,0xFFFF,0xFFFF);				else argb.set(0xFFFF,0xEEEE,0xEEEE,0xEEEE);						}					orect.set(x,y,x+64,y+64);			backCanvas->paint_rect(argb,orect);		}				backCanvas->draw_full(canvas,0,0,omblendfc_Src_Alpha,omblendfc_Inv_Src_Alpha);		picRect.bottom 	= h;		picRect.right 	= w;		picRect.top 	= 0;		picRect.left 	= 0;				err = NewGWorld(&gworld,32,&picRect,NULL,NULL,0);					ResizeImageTo(canvas->get_width(),canvas->get_height(), false);		macpixmap = GetGWorldPixMap(gworld);		LockPixels(macpixmap);				macbitmap = (BitMap*) *(macpixmap);		bpix = (unsigned long*)GetPixBaseAddr(macpixmap);		rowbytes = (long) ((unsigned short)macbitmap->rowBytes & (~ ((1<<15)|(1<<14)|(1<<13)) ));				for(y=0;y<h;y++)		for(x=0;x<w;x++)		{			omt_RGBAPixel	pix;					backCanvas->read_pixel(pix, x, y);			dpix = (unsigned long*)(((char*)bpix) + (x<<2) + (y*rowbytes));			*dpix = pix>>8;				}				backCanvas->unlock();		UnlockPixels(macpixmap);		delete backCanvas;	}}// ---------------------------------------------------------------------------//	¥ DrawSelf													   [protected]// ---------------------------------------------------------------------------//	Draw a Picturevoid LCanvasView::DrawSelf(){	Rect		 		s,d;	int					width,height,dx,dy;	PixMapHandle 		macpixmap;	BitMap				*macbitmap;	if (!canvas) return;	if (!gworld) return;	// Clear		RGBColor	rgb;	Rect	frame;	CalcLocalFrameRect(frame);	::PenNormal();		rgb.red = rgb.green = rgb.blue = 0xCCCC;	::RGBForeColor(&rgb);		::PaintRect(&frame);	rgb.red = rgb.green = rgb.blue = 0;	::RGBForeColor(&rgb);	// Copy gworld		width = canvas->get_width();	height = canvas->get_height();	dx = dy = 0;		s.left = 0;	s.top  = 0;	s.right = width;	s.bottom = height;	d.left = dx;	d.top  = dy;	d.right = dx + width;	d.bottom = dy + height;	macpixmap = GetGWorldPixMap(gworld);	macbitmap = (BitMap*) *(macpixmap);	GrafPtr	currentPort;		// Intersect with Port's visible region	::GetPort(&currentPort);		CopyBits(macbitmap, (BitMap *) *::GetPortPixMap(currentPort),&s,&d,srcCopy,NULL);}PP_End_Namespace_PowerPlant