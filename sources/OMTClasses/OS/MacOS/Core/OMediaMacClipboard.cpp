/*****************************************************************        O P E N      M E D I A     T O O L K I T              V2.5             Copyright Yves Schmid 1996-2003         See www.garagecube.com for more informations about this library.                Author(s): Yves Schmid         OMT is provided under LGPL:           This library is free software; you can redistribute it and/or          modify it under the terms of the GNU Lesser General Public          License as published by the Free Software Foundation; either          version 2.1 of the License, or (at your option) any later version.          This library is distributed in the hope that it will be useful,          but WITHOUT ANY WARRANTY; without even the implied warranty of          MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU          Lesser General Public License for more details.          You should have received a copy of the GNU Lesser General Public          License along with this library; if not, write to the Free Software          Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA          The full text of the license can be found in lgpl.txt          ******************************************************************/#include "OMediaClipboard.h"#include "OMediaMemTools.h"static OSStatus ScrapHasFlavor (ScrapRef scrap, ScrapFlavorType sft, Boolean *hasIt){	OSStatus err = noErr;	ScrapFlavorFlags sff;	err = GetScrapFlavorFlags (scrap,sft,&sff);	if (!err)		*hasIt = true;	else if (err == scrapFlavorNotFoundErr)	{		*hasIt = false;		err = noErr;	}	return err;}void OMediaClipboard::open(){}void OMediaClipboard::close(){}	void OMediaClipboard::clear(){	ClearCurrentScrap();}	bool OMediaClipboard::clip_exist(omt_ClipType t){	unsigned long ct = 0;	UInt32		sfic;	Boolean		hasFlavor;	ScrapRef 	scrap = NULL;	if (GetCurrentScrap (&scrap)!=noTypeErr) return false;	if (GetScrapFlavorCount (scrap,&sfic)!=noTypeErr) return false;	if (sfic==0) return false;	switch(t)	{		case omclip_Text:		ct = 'TEXT';		break;				default:		return false;	}	if (ScrapHasFlavor (scrap,ct,&hasFlavor)!=noTypeErr) return false;		return hasFlavor;}bool OMediaClipboard::get_clip(omt_ClipType t, OMediaMoveableMem &mem){	long ct;	ScrapRef 	scrap = NULL;	if (GetCurrentScrap (&scrap)!=noTypeErr) return false;	mem.setsize(0);	switch(t)	{		case omclip_Text:		ct = 'TEXT';		break;				default:		return false;	}	Size	siz;	if (GetScrapFlavorSize (scrap,ct,&siz)!=noTypeErr) return false;	if (!siz) return false;		mem.setsize(siz);	bool res = (GetScrapFlavorData (scrap,ct,&siz,mem.lock())==noTypeErr);	mem.unlock();		return res;}void OMediaClipboard::add_clip(omt_ClipType t, OMediaMoveableMem &mem){	ScrapRef 	scrap = NULL;	if (GetCurrentScrap (&scrap)!=noTypeErr) return;	switch(t)	{		case omclip_Text:		PutScrapFlavor (scrap, 'TEXT',kScrapFlavorMaskNone,mem.getsize(),mem.lock());		mem.unlock();		break;                                default:                break;	}}